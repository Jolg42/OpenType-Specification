<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="Author" content="Apple Inc." />
<meta name="viewport" content="width=1024" />
<link rel="shortcut icon" href="../../../favicon.ico" />
<link rel="icon" href="../../../favicon.ico" />
<link rel="stylesheet" href="https://www.apple.com/wss/fonts?family=Myriad+Set+Pro&amp;v=2" type="text/css" />
<link rel="stylesheet" href="../../../assets/styles/transition-global.css" type="text/css" />
<link rel="stylesheet" href="../../../assets/styles/transition-header.css" type="text/css" />
<link rel="stylesheet" href="https://devimages.apple.com.edgekey.net/assets/core/styles/adc.css" type="text/css" />
<link rel="stylesheet" href="https://devimages.apple.com.edgekey.net/assets/styles/topbar.css" type="text/css" />
<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/lib/prototype.js" type="text/javascript" charset="utf-8"></script>
<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/lib/scriptaculous.js" type="text/javascript" charset="utf-8"></script>
<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/browserdetect.js" type="text/javascript" charset="utf-8"></script>
<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/apple_core.js" type="text/javascript" charset="utf-8"></script>
<!--<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/search_decorator.js" type="text/javascript" charset="utf-8"></script>-->
<script src="https://devimages.apple.com.edgekey.net/assets/core/scripts/adc_core.js" type="text/javascript" charset="utf-8"></script>
<!--<script src="https://devimages.apple.com.edgekey.net/assets/scripts/ac_retina.js" type="text/javascript" charset="utf-8"></script>-->
<script src="https://devimages.apple.com.edgekey.net/assets/scripts/topbarDropdown.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript">
	document.write('<link rel="stylesheet" type="text/css" href="https://devimages.apple.com.edgekey.net/assets/styles/script.css" media="screen">');
</script>
<!-- Augmented Search -->
<!--<link rel="stylesheet" href="https://devimages.apple.com.edgekey.net/assets/styles/augmented_search.css" type="text/css">-->
<script src="https://devimages.apple.com.edgekey.net/assets/scripts/lib/jquery/jquery-1.11.0.min.js"></script>
<script>jQuery.noConflict();</script>
<script src="https://devimages.apple.com.edgekey.net/assets/scripts/lib/jquery/jquery.retinate.js" type="text/javascript" charset="utf-8"></script>
<!--<script src="https://devimages.apple.com.edgekey.net/assets/scripts/augmented_search.js"></script>-->
<script src="../../../assets/scripts/augmented_search.js"></script>
<script src="../../../assets/scripts/global-header.js"></script>

  <meta name="Author" content="Apple Inc.">
  <meta name="viewport" content="width=1024">
  <link rel="shortcut icon" href="https://devimages.apple.com.edgekey.net/favicon.ico">
  <link rel="icon" href="https://devimages.apple.com.edgekey.net/favicon.ico">
  <link rel="stylesheet" href="../AAT.css" type="text/css">
  <title>The Instruction Set</title>
</head>
<body class="white sidenav-page">
  <nav id="globalheader" role="navigation" aria-label="Global Navigation">
  <div id="gh-content" class="gh-content">
    <ul class="gh-menu">
      <li id="gh-menu-icon-toggle" class="gh-menu-icon gh-menu-icon-toggle enhance">
        <button id="gh-svg-icons" class="gh-svg-wrapper">
          <span class="text-replace">Menu</span>
          <svg x="0px" y="0px" width="100%" viewBox="0 0 96 96" class="gh-svg gh-svg-top" enable-background="new 0 0 96 96"><rect width="32" height="4" x="32" y="46" class="gh-svg-rect gh-svg-rect-top"></rect></svg>
          <svg x="0px" y="0px" width="100%" viewBox="0 0 96 96" class="gh-svg gh-svg-bottom" enable-background="new 0 0 96 96"><rect width="32" height="4" x="32" y="46" class="gh-svg-rect gh-svg-rect-bottom"></rect></svg>
        </button>
      </li>
      <li id="gh-menu-icon-home" class="gh-menu-icon gh-menu-icon-home">
        <a href="../../../index.html">
          <span class="text-replace">Apple Developer</span>
        </a>
      </li>
    </ul>
    <div class="gh-nav">
      <div class="gh-nav-view">
        <ul class="gh-nav-list">

          <li class="gh-tab gh-nav-developer" data-hires="true"><a class="gh-tab-link" href="../../../index.html"><span class="text-replace">Apple Developer</span></a></li>
          <li class="gh-tab gh-nav-technologies"><a class="gh-tab-link" href="../../../platforms/index.html">Platforms</a></li>
          <li class="gh-tab gh-nav-resources"><a class="gh-tab-link" href="../../../resources/index.html">Resources</a></li>
          <li class="gh-tab gh-nav-programs"><a class="gh-tab-link" href="../../../programs/index.html">Program</a></li>
          <li class="gh-tab gh-nav-support"><a class="gh-tab-link" href="../../../support/index.html">Support</a></li>
          <li class="gh-tab gh-nav-account">
            <a class="gh-tab-link gh-account-profile" href="https://developer.apple.com/account/">Account</a>
          </li>
          <li class="gh-tab gh-nav-search">

            <div id="gh-search" class="gh-search" role="search">
              <form action="/search/index.php" method="get" class="gh-search-form" id="gh-search-form" role="search">

                <div class="gh-search-input-wrapper">
                  <label for="gh-search-input" class="text-replace">Search Apple Developer</label>
                  <input type="text" name="q" id="gh-search-input" class="augmented gh-search-input" placeholder="Search Apple Developer" autocomplete="off" autocorrect="off" autocapitalize="off">
                </div>

                <button disabled type="submit" id="gh-search-submit" class="gh-search-submit gh-search-magnify"><span class="text-replace">Search Apple Developer</span></button>
                <button disabled type="reset" id="gh-search-reset" class="gh-search-reset"><span class="text-replace">Reset</span></button>

              </form>
            </div>

            <a class="gh-search-magnify" href="../../../search/index.html"><span class="text-replace">Search Apple Developer</span></a>

          </li>
        </ul>
      </div>
    </div>
  </div>
</nav>

  <div id="top">
<!-- SiteCatalyst code version: H.8. Copyright 1997-2006 Omniture, Inc. -->
<script type="text/javascript">
/* RSID: */
var s_account="appleglobal,appleusdeveloper"
</script>

<script type="text/javascript" src="https://www.apple.com/metrics/scripts/s_code_h.js"></script>
<script type="text/javascript">
s.pageName= AC && AC.Tracking && AC.Tracking.pageName();
s.channel="www.us.developer"

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code=s.t();if(s_code)document.write(s_code)</script>
<!-- End SiteCatalyst code version: H.8. -->
</div>

  <div id="content" class="content" data-hires="false">
    <section>

  <div id="navBar">
    <!-- NAVBARSTART -->
    <p class="bold"><a href="../index.html">TrueType Reference Manual</a></p>
    <ul class="outer">
      <li><a href="../RM01/Chap1.html">Digitizing Letterforms</a></li>
      <li><a href="../RM02/Chap2.html">The Font Engine</a></li>
      <li><a href="../RM03/Chap3.html">Instructing Fonts</a></li>
      <li><a href="../RM04/Chap4.html">The Graphics State</a></li>
      <li>The Instruction Set</li>
      <li><a href="../RM06/Chap6.html">Font Tables</a></li>
      <li class="c1">
        <ul class="inner">
          <li><a href="../RM06/Chap6.html#Intro">Introduction</a></li>
          <li><a href="../RM06/Chap6.html#Types">Data Types</a></li>
          <li><a href="../RM06/Chap6.html#Overview">Overview of TrueType</a></li>
          <li><a href="../RM06/Chap6AATIntro.html">Overview of AAT</a></li>
          <li><a href="../RM06/Chap6Tables.html">Special Tables</a></li>
          <li><a href="../RM06/Chap6.html#Directory">The Font Directory</a></li>
          <li><a href="../RM06/Chap6acnt.html">The <code>'acnt'</code> table</a></li>
          <li><a href="../RM06/Chap6ankr.html">The <code>'ankr'</code> table</a></li>
          <li><a href="../RM06/Chap6avar.html">The <code>'avar'</code> table</a></li>
          <li><a href="../RM06/Chap6bdat.html">The <code>'bdat'</code> table</a></li>
          <li><a href="../RM06/Chap6bhed.html">The <code>'bhed'</code> table</a></li>
          <li><a href="../RM06/Chap6bloc.html">The <code>'bloc'</code> table</a></li>
          <li><a href="../RM06/Chap6bsln.html">The <code>'bsln'</code> table</a></li>
          <li><a href="../RM06/Chap6cmap.html">The <code>'cmap'</code> table</a></li>
          <li><a href="../RM06/Chap6cvar.html">The <code>'cvar'</code> table</a></li>
          <li><a href="../RM06/Chap6cvt.html">The <code>'cvt '</code> table</a></li>
          <li><a href="../RM06/Chap6EBSC.html">The <code>'EBSC'</code> table</a></li>
          <li><a href="../RM06/Chap6fdsc.html">The <code>'fdsc'</code> table</a></li>
          <li><a href="../RM06/Chap6feat.html">The <code>'feat'</code> table</a></li>
          <li><a href="../RM06/Chap6fmtx.html">The <code>'fmtx'</code> table</a></li>
          <li><a href="../RM06/Chap6fond.html">The <code>'fond'</code> table</a></li>
          <li><a href="../RM06/Chap6fpgm.html">The <code>'fpgm'</code> table</a></li>
          <li><a href="../RM06/Chap6fvar.html">The <code>'fvar'</code> table</a></li>
          <li><a href="../RM06/Chap6gasp.html">The <code>'gasp'</code> table</a></li>
          <li><a href="../RM06/Chap6gcid.html">The <code>'gcid'</code> table</a></li>
          <li><a href="../RM06/Chap6glyf.html">The <code>'glyf'</code> table</a></li>
          <li><a href="../RM06/Chap6gvar.html">The <code>'gvar'</code> table</a></li>
          <li><a href="../RM06/Chap6hdmx.html">The <code>'hdmx'</code> table</a></li>
          <li><a href="../RM06/Chap6head.html">The <code>'head'</code> table</a></li>
          <li><a href="../RM06/Chap6hhea.html">The <code>'hhea'</code> table</a></li>
          <li><a href="../RM06/Chap6hmtx.html">The <code>'hmtx'</code> table</a></li>
          <li><a href="../RM06/Chap6just.html">The <code>'just'</code> table</a></li>
          <li><a href="../RM06/Chap6kern.html">The <code>'kern'</code> table</a></li>
          <li><a href="../RM06/Chap6kerx.html">The <code>'kerx'</code> table</a></li>
          <li><a href="../RM06/Chap6lcar.html">The <code>'lcar'</code> table</a></li>
          <li><a href="../RM06/Chap6loca.html">The <code>'loca'</code> table</a></li>
          <li><a href="../RM06/Chap6maxp.html">The <code>'maxp'</code> table</a></li>
          <li><a href="../RM06/Chap6meta.html">The <code>'meta'</code> table</a></li>
          <li><a href="../RM06/Chap6mort.html">The <code>'mort'</code> table</a></li>
          <li><a href="../RM06/Chap6morx.html">The <code>'morx'</code> table</a></li>
          <li><a href="../RM06/Chap6name.html">The <code>'name'</code> table</a></li>
          <li><a href="../RM06/Chap6opbd.html">The <code>'opbd'</code> table</a></li>
          <li><a href="../RM06/Chap6OS2.html">The <code>'OS/2'</code> table</a></li>
          <li><a href="../RM06/Chap6post.html">The <code>'post'</code> table</a></li>
          <li><a href="../RM06/Chap6prep.html">The <code>'prep'</code> table</a></li>
          <li><a href="../RM06/Chap6prop.html">The <code>'prop'</code> table</a></li>
          <li><a href="../RM06/Chap6sbix.html">The <code>'sbix'</code> table</a></li>
          <li><a href="../RM06/Chap6trak.html">The <code>'trak'</code> table</a></li>
          <li><a href="../RM06/Chap6vhea.html">The <code>'vhea'</code> table</a></li>
          <li><a href="../RM06/Chap6vmtx.html">The <code>'vmtx'</code> table</a></li>
          <li><a href="../RM06/Chap6xref.html">The <code>'xref'</code> table</a></li>
          <li><a href="../RM06/Chap6Zapf.html">The <code>'Zapf'</code> table</a></li>
        </ul>
      </li>
      <li><a href="../RM07/appendixA.html">Instruction Set Summary</a></li>
      <li><a href="../RM07/appendixB.html">Glyph Mappings</a></li>
      <li><a href="../RM08/appendixE.html">Converting Outlines</a></li>
	<li><a href="../RM09/AppendixF.html">Font Feature Registry</a></li>
    </ul><!-- NAVBAREND -->
  </div>
  <div id="chapterContent">
    <center>
      <header><h1>The Instruction Set</h1></header>
    </center>
    <h2 id="contents">Contents</h2>
    <ul class="circle">
      <li><a href="Chap5.html#intro">Introduction</a></li>
      <li>
        <a href="Chap5.html#understanding">Understanding the instruction summaries</a>
        <ul class="dot">
          <li><a href="Chap5.html#format">The instruction summary format</a></li>
          <li><a href="Chap5.html#interactions">Denoting stack interactions</a></li>
          <li><a href="Chap5.html#data_types">Data types used in the stack</a></li>
          <li><a href="Chap5.html#illustrations">Understanding the illustrations</a></li>
        </ul>
      </li>
      <li>
        <a href="Chap5.html#instructions">The Instructions</a>
        <ul class="dot">
          <li><a href="Chap5.html#AA">AA[] Adjust Angle</a></li>
          <li><a href="Chap5.html#ABS">ABS[] ABSolute value</a></li>
          <li><a href="Chap5.html#ADD">ADD[] ADD</a></li>
          <li><a href="Chap5.html#ALIGNPTS">ALIGNPTS[] ALIGN Points</a></li>
          <li><a href="Chap5.html#ALIGNRP">ALIGNRP[] ALIGN to Reference Point</a></li>
          <li><a href="Chap5.html#AND">AND[] logical AND</a></li>
          <li><a href="Chap5.html#CALL">CALL[] CALL function</a></li>
          <li><a href="Chap5.html#CEILING">CEILING[] CEILING</a></li>
          <li><a href="Chap5.html#CINDEX">CINDEX[] Copy the INDEXed element to the top of the stack</a></li>
          <li><a href="Chap5.html#CLEAR">CLEAR[] CLEAR the stack</a></li>
          <li><a href="Chap5.html#DEBUG">DEBUG[] DEBUG call</a></li>
          <li><a href="Chap5.html#DELTAC1">DELTAC1[] DELTA exception C1</a></li>
          <li><a href="Chap5.html#DELTAC2">DELTAC2[] DELTA exception C2</a></li>
          <li><a href="Chap5.html#DELTAC3">DELTAC3[] DELTA exception C3</a></li>
          <li><a href="Chap5.html#DELTAP1">DELTAP1[] DELTA exception P1</a></li>
          <li><a href="Chap5.html#DELTAP2">DELTAP2[] DELTA exception P2</a></li>
          <li><a href="Chap5.html#DELTAP3">DELTAP3[] DELTA exception P3</a></li>
          <li><a href="Chap5.html#DEPTH">DEPTH[] DEPTH of the stack</a></li>
          <li><a href="Chap5.html#DIV">DIV[] DIVide</a></li>
          <li><a href="Chap5.html#DUP">DUP[] DUPlicate top stack element</a></li>
          <li><a href="Chap5.html#EIF">EIF[] End IF</a></li>
          <li><a href="Chap5.html#ELSE">ELSE[] ELSE clause</a></li>
          <li><a href="Chap5.html#ENDF">ENDF[] END Function definition</a></li>
          <li><a href="Chap5.html#EQ">EQ[] EQual</a></li>
          <li><a href="Chap5.html#EVEN">EVEN[] EVEN</a></li>
          <li><a href="Chap5.html#FDEF">FDEF[] Function DEFinition</a></li>
          <li><a href="Chap5.html#FLIPOFF">FLIPOFF[] set the auto FLIP Boolean to OFF</a></li>
          <li><a href="Chap5.html#FLIPON">FLIPON[] set the auto FLIP Boolean to ON</a></li>
          <li><a href="Chap5.html#FLIPPT">FLIPPT[] FLIP PoinT</a></li>
          <li><a href="Chap5.html#FLIPRGOFF">FLIPRGOFF[] FLIP RanGe OFF</a></li>
          <li><a href="Chap5.html#FLIPRGON">FLIPRGON[] FLIP RanGe ON</a></li>
          <li><a href="Chap5.html#FLOOR">FLOOR[] FLOOR</a></li>
          <li><a href="Chap5.html#GC">GC[a] Get Coordinate projected onto the projection vector</a></li>
          <li><a href="Chap5.html#GETINFO">GETINFO[] GET INFOrmation</a></li>
          <li><a href="Chap5.html#GFV">GFV[] Get Freedom Vector</a></li>
          <li><a href="Chap5.html#GPV">GPV[] Get Projection Vector</a></li>
          <li><a href="Chap5.html#GT">GT[] Greater Than</a></li>
          <li><a href="Chap5.html#GTEQ">GTEQ[] Greater Than or EQual</a></li>
          <li><a href="Chap5.html#IDEF">IDEF[] Instruction DEFinition</a></li>
          <li><a href="Chap5.html#IF">IF[] IF test</a></li>
          <li><a href="Chap5.html#INSTCTRL">INSTCTRL INSTRuction execution ConTRoL</a></li>
          <li><a href="Chap5.html#IP">IP[] Interpolate Point</a></li>
          <li><a href="Chap5.html#ISECT">ISECT[] moves point p to the InterSECTion of two lines</a></li>
          <li><a href="Chap5.html#IUP">IUP[a] Interpolate Untouched Points through the outline</a></li>
          <li><a href="Chap5.html#JMPR">JMPR JuMP Relative</a></li>
          <li><a href="Chap5.html#JROF">JROF[] Jump Relative On False</a></li>
          <li><a href="Chap5.html#JROT">JROT[] Jump Relative On True</a></li>
          <li><a href="Chap5.html#LOOPCALL">LOOPCALL[] LOOP and CALL function</a></li>
          <li><a href="Chap5.html#LT">LT[] Less Than</a></li>
          <li><a href="Chap5.html#LTEQ">LTEQ[] Less Than or Equal</a></li>
          <li><a href="Chap5.html#MAX">MAX[] MAXimum of top two stack elements</a></li>
          <li><a href="Chap5.html#MD">MD[a] Measure Distance</a></li>
          <li><a href="Chap5.html#MDRP">MDAP[a] Move Direct Absolute Point</a></li>
          <li><a href="Chap5.html#MDRP">MDRP[abcde] Move Direct Relative Point</a></li>
          <li><a href="Chap5.html#MIAP">MIAP[a] Move Indirect Absolute Point</a></li>
          <li><a href="Chap5.html#MIN">MIN[] MINimum of top two stack elements</a></li>
          <li><a href="Chap5.html#MINDEX">MINDEX[] Move the INDEXed element to the top of the stack</a></li>
          <li><a href="Chap5.html#MIRP">MIRP[abcde] Move Indirect Relative Point</a></li>
          <li><a href="Chap5.html#MPPEM">MPPEM[] Measure Pixels Per EM</a></li>
          <li><a href="Chap5.html#MPS">MPS[] Measure Point Size</a></li>
          <li><a href="Chap5.html#MSIRP">MSIRP[a] Move Stack Indirect Relative Point</a></li>
          <li><a href="Chap5.html#MUL">MUL[] MULtiply</a></li>
          <li><a href="Chap5.html#NEG">NEG[] NEGate</a></li>
          <li><a href="Chap5.html#NEQ">NEQ[] Not EQual</a></li>
          <li><a href="Chap5.html#NOT">NOT[] logical NOT</a></li>
          <li><a href="Chap5.html#NPUSHB">NPUSHB[] PUSH N Bytes</a></li>
          <li><a href="Chap5.html#NPUSHW">NPUSHW[] PUSH N Words</a></li>
          <li><a href="Chap5.html#NROUND">NROUND[ab] No ROUNDing of value</a></li>
          <li><a href="Chap5.html#ODD">ODD[] ODD</a></li>
          <li><a href="Chap5.html#OR">OR[] logical OR</a></li>
          <li><a href="Chap5.html#POP">POP[] POP top stack element</a></li>
          <li><a href="Chap5.html#PUSHB">PUSHB[abc] PUSH Bytes</a></li>
          <li><a href="Chap5.html#PUSHW">PUSHW[abc] PUSH Words</a></li>
          <li><a href="Chap5.html#RCVT">RCVT[] Read Control Value Table entry</a></li>
          <li><a href="Chap5.html#RDTG">RTDG[] Round Down To Grid</a></li>
          <li><a href="Chap5.html#ROFF">ROFF[] Round OFF</a></li>
          <li><a href="Chap5.html#ROLL">ROLL ROLL the top three stack elements</a></li>
          <li><a href="Chap5.html#ROUND">ROUND[ab] ROUND value</a></li>
          <li><a href="Chap5.html#RS">RS[] Read Store</a></li>
          <li><a href="Chap5.html#RTDG">RTDG[] Round To Double Grid</a></li>
          <li><a href="Chap5.html#RTG">RTG[] Round To Grid</a></li>
          <li><a href="Chap5.html#RTHG">RTHG[] Round To Half Grid</a></li>
          <li><a href="Chap5.html#RUTG">RUTG[] Round Up To Grid</a></li>
          <li><a href="Chap5.html#S45ROUND">S45ROUND[] Super ROUND 45 degrees</a></li>
          <li><a href="Chap5.html#SANGW">SANGW[] Set Angle Weight</a></li>
          <li><a href="Chap5.html#SCANCTRL">SCANCTRL[] SCAN conversion ConTRoL</a></li>
          <li><a href="Chap5.html#SCANTYPE">SCANTYPE[] SCANTYPE</a></li>
          <li><a href="Chap5.html#SCFS">SCFS[] Sets Coordinate From the Stack using projection vector and freedom vector</a></li>
          <li><a href="Chap5.html#SCVTCI">SCVTCI[] Set Control Value Table Cut-In</a></li>
          <li><a href="Chap5.html#SDB">SDB[] Set Delta Base in the graphics state</a></li>
          <li><a href="Chap5.html#SDPVTL">SDPVTL[a] Set Dual Projection Vector To Line</a></li>
          <li><a href="Chap5.html#SDS">SDS[] Set Delta Shift in the graphics state</a></li>
          <li><a href="Chap5.html#SFVFS">SFVFS[] Set Freedom Vector From Stack</a></li>
          <li><a href="Chap5.html#SFVTCA">SFVTCA[a] Set Freedom Vector To Coordinate Axis</a></li>
          <li><a href="Chap5.html#SFVTL">SFVTL[a] Set Freedom Vector To Line</a></li>
          <li><a href="Chap5.html#SFVTPV">SFVTP[] Set Freedom Vector To Projection Vector</a></li>
          <li><a href="Chap5.html#SHC">SHC[a] SHift Contour using reference point</a></li>
          <li><a href="Chap5.html#SHP">SHP[a] SHift Point using reference point</a></li>
          <li><a href="Chap5.html#SHPIX">SHPIX[] SHift point by a PIXel amount</a></li>
          <li><a href="Chap5.html#SHZ">SHZ[a] SHift Zone using reference point</a></li>
          <li><a href="Chap5.html#SLOOP">SLOOP[] Set LOOP variable</a></li>
          <li><a href="Chap5.html#SMD">SMD[] Set Minimum Distance</a></li>
          <li><a href="Chap5.html#SPVFS">SPVFS[] Set Projection Vector From Stack</a></li>
          <li><a href="Chap5.html#SPVTCA">SPVTCA[a] Set Projection Vector To Coordinate Axis</a></li>
          <li><a href="Chap5.html#SPVTL">SPVTL[a] Set Projection Vector To Line</a></li>
          <li><a href="Chap5.html#SROUND">SROUND[] Super ROUND</a></li>
          <li><a href="Chap5.html#SRPO">SRP0[] Set Reference Point 0</a></li>
          <li><a href="Chap5.html#SRP1">SRP1[] Set Reference Point 1</a></li>
          <li><a href="Chap5.html#SRP2">SRP2[] Set Reference Point 2</a></li>
          <li><a href="Chap5.html#SSW">SSW[] Set Single Width</a></li>
          <li><a href="Chap5.html#SSWCI">SSWCI[] Set Single Width Cut-In</a></li>
          <li><a href="Chap5.html#SUB">SUB[] SUBtract</a></li>
          <li><a href="Chap5.html#SVTCA">SVTCA[a] Set freedom and projection Vectors To Coordinate Axis</a></li>
          <li><a href="Chap5.html#SWAP">SWAP[] SWAP the top two elements on the stack</a></li>
          <li><a href="Chap5.html#SZP0">SZP0[] Set Zone Pointer 0</a></li>
          <li><a href="Chap5.html#SZP1">SZP1[] Set Zone Pointer 1</a></li>
          <li><a href="Chap5.html#SZP2">SZP2[] Set Zone Pointer 2</a></li>
          <li><a href="Chap5.html#SZPS">SZPS[] Set Zone PointerS</a></li>
          <li><a href="Chap5.html#UTP">UTP[] UnTouch Point</a></li>
          <li><a href="Chap5.html#WCVTF">WCVTF[] Write Control Value Table in Funits</a></li>
          <li><a href="Chap5.html#WCVTP">WCVTP[] Write Control Value Table in Pixel units</a></li>
          <li><a href="Chap5.html#WS">WS[] Write Store</a></li>
        </ul>
      </li>
    </ul>
    <h2 id="intro">Introduction</h2>This section presents an alphabetical listing of the TrueType instruction set. Each description begins with the basic facts. A brief description of the instruction's functionality follows. This material is intended for reference. For an introduction to the TrueType language see <a href="../RM03/Chap3.html">Instructing Fonts</a> .
    <p><br></p>
    <h2 id="understanding">Understanding the instruction summaries</h2>The following sections summarize the basic information needed to understand the instruction summaries that follow.<br>
    <h3 id="format">The instruction summary format</h3>Each instruction description begins with a tabulation of basic information as shown in FIGURE 1 below. For a given instruction, only the relevant information fields are included. For example, the "From IS" field is omitted for all but the "push" instructions. In generial, if the "Uses" field is omitted from a particular instruction description, it is safe to assume that the instruction has no graphics state dependencies. The instruct control state variable is an exception to this rule. It will not appear in the uses field for each instruction though it can, turn off the execution of all instructions.<br>
    <p><strong><font size="2">FIGURE 1</font> The instruction summary format</strong></p>
    <table width="80%">
      <tr valign="middle">
        <td valign="middle">MNEMONIC[flags]</td>
        <td valign="middle">explanation of mnemonic</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Code Range</td>
        <td valign="middle">the range of hexadecimal codes identifying this instruction and its variants</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Flags</td>
        <td valign="middle">an explanation of the meaning of a bracketed binary number</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">From IS</td>
        <td valign="middle">any arguments taken from the instruction stream by push instructions</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Pops</td>
        <td valign="middle">any arguments popped from the stack</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Pushes</td>
        <td valign="middle">any arguments pushed onto the stack</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Uses</td>
        <td valign="middle">any state variables whose value this instruction depends upon</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Sets</td>
        <td valign="middle">any state variables set by this instruction</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Gets</td>
        <td valign="middle">the state variable whose value is retrieved by this instruction</td>
      </tr>
      <tr valign="middle">
        <td valign="middle">Related instructions</td>
        <td valign="middle">any closely related instruction including those with a similar or an opposite effect</td>
      </tr>
    </table>
    <p><br></p>
    <h3 id="interactions">Denoting stack interactions</h3>In the instruction summaries that follow, the arguments an instruction pops from the stack or pushes onto the stack will be listed along with a brief description of their purpose and data type.<br>
    <p>In the case of arguments popped from the stack, the first argument listed is the first one popped from the stack, the second is the next one popped and so forth.<br></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="top" rowspan="3">Pops</td>
        <td align="left" valign="middle">arg<sub>3</sub>: first argument popped (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">arg<sub>2</sub>: second argument popped (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">arg<sub>1</sub>: third argument popped (F26Dot6)</td>
      </tr>
    </table>
    <p><br></p>
    <p>In the case of arguments popped from the stack, the first result pushed onto the stack appears first, the second result pushed appears below it and so forth.<br></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="top" rowspan="2">Pushes</td>
        <td align="left" valign="middle">result1: first result pushed (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">result2: second result pushed (F26Dot6)</td>
      </tr>
    </table>
    <p><br></p>
    <p>When it is necessary to summarize the stack interaction of an instruction, the information will be written in a single line. The items popped are on the left to the left of two hyphens, the items pushed are to the right. The example above would be written:<br></p>
    <p>( arg1 arg2 arg3 -- result1 result2 ).</p>
    <p>The right most item in the list is always the item at the top of the stack.<br></p>
    <p><br></p>
    <h3 id="data_types">Data types used in the stack</h3>Many of the TrueType instructions interact with the interpreter stack. In simplest terms, they take data from the stack and return results to the stack. The stack elements that they manipulate are all 32 bit values. The way in which instructions interpret these values varies. Some consider all 32 bits pushed or popped to be significant. Some use only certain bits. Some treat the 32 bit quantity as a signed integer, some as an unsigned integer and some as a fixed point value.<br>
    <p>The data types that can appear on the stack are listed in Table 1 below.<br></p>
    <p>In cases where only a portion of the 32 bits pushed or popped are relevant, the data type has a name that begins with a capital letter E for "extended." Unsigned values are extended to 32 bits with zeroes to the left of the bits that are significant. Signed values are sign extended to 32 bits.<br></p>
    <p>Fixed point numbers have names that begin with the letter F. The name consists of the number of bits representing the integral part of the number, the letters "DOT", representing the binary point. followed by the number of fractional bits. An extended fixed point number begins with the letters EF.<br></p>
    <p>Generic stack elements have the data type StkElt. Any 32 bit quantity can have this data type.<br></p>
    <p id="TABLE1"><font size="2"><strong>Table 1</strong> : The instruction set data type</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Data type</th>
        <th align="left" valign="middle">Description</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Eint8</td>
        <td align="left" valign="middle">sign extended 8-bit interger</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Euint16</td>
        <td align="left" valign="middle">zero extended 16-bit unsigned integer</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">EFWord</td>
        <td align="left" valign="middle">sign extended 16-bit signed integer that describes a quanity in FUnits, the smallest measurable unit in the em space</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">EF2Dot14</td>
        <td align="left" valign="middle">sign extended 16-bit signed fixed number with the low 14 bits representing fraction</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">uint32</td>
        <td align="left" valign="middle">32-bit unsigned integer</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">int32</td>
        <td align="left" valign="middle">32-bit signed interger</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">F26Dot6</td>
        <td align="left" valign="middle">32-bit signed fixed number with the low 6 bits representing fraction</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">StkElt</td>
        <td align="left" valign="middle">any 32 bit quantity</td>
      </tr>
    </table>
    <p><br></p>
    <h3 id="illustrations">Understanding the illustrations</h3>A number of instructions have accompanying illustrations. Most of these illustrations explain the effects an instruction has on the position of points in a glyph outline. FIGURE 1 lists the conventions used in those illustrations. Remember that,<br>
    <ul>
      <li>Unless otherwise noted, distances are measured along the <em>projection vector</em><br></li>
      <li>Unless otherwise noted, instructions move points along the <em>freedom vector</em><br></li>
    </ul>
    <p>For more information on moving points see <a href="../RM03/Chap3.html">Instructing Fonts</a> .<br></p>
    <p><font size="2"><strong>FIGURE 1</strong> Key to illustrations</font></p>
    <p><img src="F025_instr1.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <h2 id="instructions">The Instructions</h2>
    <p id="AA"><font size="4">AA[] Adjust Angle</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x7F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops p:</td>
        <td align="left" valign="middle">point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SANGW[ ]</td>
      </tr>
    </table><br>
    Pops one argument from the stack. This instruction is anachronistic and has no other effect.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ABS"><font size="4">ABS[] ABSolute value</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x64</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: fixed point number (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">|n|: absolute value of n (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" colspan="2">Replaces the number at the top of the stack with its absolute value.</td>
      </tr>
    </table><br>
    Pops a 26.6 fixed point number, n, off the stack and pushes the absolute value of n onto the stack.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ADD"><font size="4">ADD[] ADD</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x60</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n2: fixed point number (F26Dot6) n1: fixed point number (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">sum: n1 + n2(F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" colspan="2">Adds the top two numbers on the stack.</td>
      </tr>
    </table><br>
    Pops two 26.6 fixed point numbers, n2 and n1, off the stack and pushes the sum of those two numbers onto the stack.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ALIGNPTS"><font size="4">ALIGNPTS[] ALIGN Points</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x27</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p2: point number (uint32) p1: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with point p2 and zp1 with point p1, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ALIGNRP[ ]</td>
      </tr>
    </table><br>
    Aligns the two points whose numbers are the top two items on the stack along an axis orthogonal to the projection vector.<br>
    <p>Pops two point numbers, p2 and p1, from the stack and makes the distance between them zero by moving both points along the freedom vector to the average of their projections along the projection vector.<br></p>
    <p>In the illustration below, points p1 and p2 are moved along the freedom vector until the projected distance between them is reduced to zero. The distance from A to B equals d/2 which equals the distance from B to C. The value d/2 is one-half the original projected distance between p1 and p2.<br>
    <img src="F025_instr2.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ALIGNRP"><font size="4">ALIGNRP[] ALIGN to Reference Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x3C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p1, p2, , ploopvalue: point numbers (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp1 with point p and zp0 with rp0, loop, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ALIGNPTS[ ]</td>
      </tr>
    </table><br>
    Aligns the points whose numbers are at the top of the stack with the point referenced by rp0.<br>
    <p>Pops point numbers, p1, p2, , ploopvalue, from the stack and aligns those points with the current position of rp0 by moving each point pi so that the projected distance from pi to rp0 is reduced to zero. The number of points aligned depends up the current setting the state variable loop.<br></p>
    <p>In the illustration below, point p is moved along the freedom vector until its projected distance from rp0 is reduced to zero.<br>
    <img src="F025_instr3.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="AND"><font size="4">AND[] logical AND</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x5A<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element (StkElt) e1: stack element (StkElt)<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(e1 and e2): logical and of e1 and e2 (uint32)<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">OR[ ]</td>
      </tr>
    </table><br>
    Takes the logical and of the top two stack elements.<br>
    <p>Pops the top two elements, e2 and e1, from the stack and pushes the result of a logical and of the two elements onto the stack. Zero is pushed if either or both of the elements are FALSE (have the value zero). One is pushed if both elements are TRUE (have a non-zero value).<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="CALL"><font size="4">CALL[] CALL function</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x2B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">f: function identifier number (int32 in the range 0 through (n-1) where n is specified in the 'maxp' table)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FDEF[ ], EIF[ ]</td>
      </tr>
    </table><br>
    Calls the function identified by the number of the top of the stack.<br>
    <p>Pops a function identifier number, f, from the stack and calls the function identified by f. The instructions contained in the function body will be executed. When execution of the function is complete, the instruction pointer will move to the next location in the instruction stream where execution of instructions will resume.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="CEILING"><font size="4">CEILING[] CEILING</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x67</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: fixed point number (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">n : ceiling of n (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLOOR[ ]</td>
      </tr>
    </table><br>
    Takes the ceiling of the number at the top of the stack.<br>
    <p>Pops a number n from the stack and pushes n , the least integer value greater than or equal to n. Note that the ceiling of n, though an integer value, is expressed as 26.6 fixed point number.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="CINDEX"><font size="4">CINDEX[] Copy the INDEXed element to the top of the stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x25</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">k: stack element number (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">ek: kth stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="4">Stack before</td>
        <td align="left" valign="middle">k: stack element number</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">...</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ek: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="4">Stack after</td>
        <td align="left" valign="middle">ek: indexed element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">...</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ek: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MINDEX[ ]</td>
      </tr>
    </table><br>
    Copies the indexed stack element to the top of the stack.<br>
    <p>Pops a stack element number, k, from the stack and pushes a copy of the kth stack element on the top of the stack. Since it is a copy that is pushed, the kth element remains in its original position. This feature is the key difference between the CINDEX[ ] and MINDEX[ ] instructions.<br></p>
    <p>A zero or negative value for k is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="CLEAR"><font size="4">CLEAR[] CLEAR the stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x22</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">all the items on the stack (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
    </table><br>
    Clears all elements from the stack.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DEBUG"><font size="4">DEBUG[] DEBUG call</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x4F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: integer (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
    </table><br>
    Pops an integer from the stack. In non-debugging versions of the interpreter, the execution of instructions will continue. In debugging versions, available to font developers, an implementation dependent debugger will be invoked.<br>
    <p>This instruction is only for debugging purposes and should not be a part of a finished font. Some implementations do not support this instruction.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAC1"><font size="4">DELTAC1[] DELTA exception C1</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x73</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: number of pairs of exception specifications and CVT entry numbers (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, cn, argn-1,cn-1, , arg1, c1: pairs of CVT entry number and exception specifications (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">delta shift, delta base<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td>
      </tr>
    </table>
    <p>Creates an exception to one or more CVT values, each at a specified point size and by a specified amount.<br></p>
    <p>Pops an integer, n, followed by n pairs of exception specifications and control value table entry numbers. DELTAC1[] changes the value in each CVT entry specified at the size and by the pixel amount specified in its paired argument.<br></p>
    <p>The 8 bit arg component of the DELTAC1[] instruction decomposes into two parts. The most significant 4 bits represent the relative number of pixels per em at which the exception is applied. The least significant 4 bits represent the magnitude of the change to be made.<br></p>
    <p>The relative number of pixels per em is a function of the value specified in the argument and the delta base. The DELTAC1[] instruction works at pixel per em sizes beginning with the delta base through the delta_base + 15. To invoke an exception at a larger pixel per em size, use the DELTAC2[] or DELTAC3[] instruction which can affect changes at sizes up to delta_base + 47 or, if necessary, increase the value of the delta base.<br></p>
    <p>The magnitude of the move is specified, in a coded form, in the instruction. Table 5 lists the mapping from exception values and the magnitude of the move made.The size of the step depends on the value of the delta shift.<br></p>
    <p><font size="2"><strong>Table 4</strong>: Magnitude values mapped to number of steps to move</font></p>
    <p><br></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Selector</th>
        <td align="left" valign="middle">0</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">6</td>
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">8</td>
        <td align="left" valign="middle">9</td>
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">12</td>
        <td align="left" valign="middle">13</td>
        <td align="left" valign="middle">14</td>
        <td align="left" valign="middle">15</td>
      </tr>
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Number of steps</th>
        <td align="left" valign="middle">-8</td>
        <td align="left" valign="middle">-7</td>
        <td align="left" valign="middle">-6</td>
        <td align="left" valign="middle">-5</td>
        <td align="left" valign="middle">-4</td>
        <td align="left" valign="middle">-3</td>
        <td align="left" valign="middle">-2</td>
        <td align="left" valign="middle">-1</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">6</td>
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">8</td>
      </tr>
    </table>
    <p>For additional information on the DELTA instructions see <a href="../RM03/Chap3.html">Instructing Fonts</a> .<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAC2"><font size="4">DELTAC2[] DELTA exception C2</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x74</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: number of pairs of exception specifications and CVT entry numbers (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, cn, argn-1,cn-1, , arg1, c1: pairs of CVT entry number and exception specifications (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">delta shift, delta base</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[]</td>
      </tr>
    </table><br>
    Creates an exception to one or more CVT values, each at a specified point size and by a specified amount.<br>
    <p>Pops an integer, n, followed by n pairs of exception specifications and CVT entry numbers. DELTAC2[] changes the value in each CVT entry specified at the size and by the amount specified in its paired argument.<br></p>
    <p>The DELTAC2[] instruction is exactly the same as the DELTAC1[] instruction except for operating at pixel per em sizes beginning with the (delta_base + 16) through the (delta_base + 31). To invoke an exception at a smaller pixel per em size, use the DELTAC1[] instruction. To invoke an exception at a smaller pixel per em size, use the DELTAC3[] instruction which can affect changes at sizes up to delta_base + 47 or, if necessary, change the value of the delta base.<br></p>
    <p>For more information see the entry for DELTAC1[] or <a href="../RM03/Chap3.html">Instructing Fonts</a> .<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAC3"><font size="4">DELTAC3[] DELTA exception C3</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x75</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: number of pairs of CVT entry numbers and exception specifications (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, cn, argn-1,cn-1, , arg1, c1: pairs of CVT entry number and exception specifications (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">delta shift, delta base</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3[], DELTAP[], DELTAP2[], DELTAP3[]</td>
      </tr>
    </table><br>
    Creates an exception to one or more CVT values, each at a specified point size and by a specified amount.<br>
    <p>Pops an integer, n, followed by n pairs of exception specifications and CVT entry numbers. DELTAC3[] changes the value in each CVT entry specified at the size and by the amount specified in its paired argument.<br></p>
    <p>The DELTAC3[] instruction is exactly the same as the DELTAC1 instruction except for operating at pixel per em sizes beginning with the (delta_base + 32) through the (delta_base + 47).<br></p>
    <p>For more information see the entry for DELTAC1[] or <a href="../RM03/Chap3.html">Instructing Fonts</a> .<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAP1"><font size="4">DELTAP1[] DELTA exception P1</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range 0x5D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops n: number of pairs of exception specifications and points (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, pn, argn-1, pn-1, , arg1, p1: n pairs of exception specifications and points (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, delta base, delta shift, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td>
      </tr>
    </table><br>
    Creates an exception at one or more point locations, each at a specified point size and by a specified amount.<br>
    <p>DELTAP1[] works on the points in the zone reference by zp0. It moves the specified points at the size and by the amount specified in the paired argument. Moving a point makes it possible to turn on or off selected pixels in the bitmap that will be created when the affected outline is scan converted. An arbitrary number of points and arguments can be specified.<br></p>
    <p>The grouping [argi, pi] can be executed n times. The value of argi consists of a byte with lower four bits of which represent the magnitude of the exception and the upper four bits, the relative pixel per em value.<br></p>
    <p>The actual pixel per em size at which a DELTAP instruction works is a function of the relative pixel per em size and the delta base. The DELTAP1[] instruction works at pixel per em sizes beginning with the delta base through the delta_base + 15. To invoke an exception at a larger pixel per em size, use the DELTAP2[] or DELTAP3[] instruction which together can affect changes at sizes up to delta_base + 47 or, if necessary, increase the value of the delta base.<br></p>
    <p>The magnitude of the move is specified, in a coded form, in the instruction. Table 5 lists the mapping from exception values used in a DELTA instruction to the magnitude in steps of the move made. The size of the step depends on the value of the delta shift.<br></p>
    <p><font size="2"><strong>Table 5</strong>: Magnitude values mapped to number of steps to move</font></p>
    <p><br></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Selector</th>
        <td align="left" valign="middle">0</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">6</td>
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">8</td>
        <td align="left" valign="middle">9</td>
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">12</td>
        <td align="left" valign="middle">13</td>
        <td align="left" valign="middle">14</td>
        <td align="left" valign="middle">15</td>
      </tr>
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Number of steps</th>
        <td align="left" valign="middle">-8</td>
        <td align="left" valign="middle">-7</td>
        <td align="left" valign="middle">-6</td>
        <td align="left" valign="middle">-5</td>
        <td align="left" valign="middle">-4</td>
        <td align="left" valign="middle">-3</td>
        <td align="left" valign="middle">-2</td>
        <td align="left" valign="middle">-1</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">6</td>
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">8</td>
      </tr>
    </table><br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAP2"><font size="4">DELTAP2[] DELTA exception P2</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x71</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: number of pairs of exception specifications and points (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, pn, argn-1, pn-1, , arg1, p1: n pairs of exception specifications and points (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, delta shift, delta base, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td>
      </tr>
    </table><br>
    Creates an exception at one or more point locations, each at a specified point size and by a specified amount.<br>
    <p>DELTAP2[] works on the points in the zone reference by zp0. It moves the specified points at the size and by the amount specified in the paired argument. Moving a point makes it possible to turn on or off selected pixels in the bitmap that will be created when the affected outline is scan converted. An arbitrary number of points and arguments can be specified.<br></p>
    <p>The DELTAP2[] instruction is identical to the DELTAP1[] instruction save for operating at pixel per em sizes beginning with the (delta_base + 16) through the (delta_base + 31). To invoke an exception at a smaller pixel per em size, use the DELTAP1[] instruction. To invoke an exception at a smaller pixel per em size, use the DELTAP3[] instruction. If necessary, change the value of the delta_base.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DELTAP3"><font size="4">DELTAP3[] DELTA exception P3</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x72</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: number of pairs of exception specifications and points (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">argn, pn, argn-1, pn-1, , arg1, p1: n pairs of exception specifications and points (pairs of uint32s)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, delta base, delta shift, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DELTAC2[ ], DELTAC3, DELTAP1, DELTAP2, DELTAP3</td>
      </tr>
    </table><br>
    Creates an exception at one or more point locations, each at a specified point size and by a specified amount.<br>
    <p>Pops an integer, n, followed by n pairs of exception specifications and points. DELTAP3[] works on the points in the zone reference by zp0. It moves the specified points at the size and by the amount specified in the paired argument. Moving a point makes it possible to turn on or off selected pixels in the bitmap that will be created when the affected outline is scan converted. An arbitrary number of points and arguments can be specified.<br></p>
    <p>The DELTAP3[] instruction is identical to the DELTAP1[] instruction save for operating at pixel per em sizes beginning with the (delta_base + 32) through the (delta base + 47). To invoke an exception at a smaller pixel per em size, use the DELTAP1[] or the DELTAP2[] instruction. If necessary, change the value of the delta base.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DEPTH"><font size="4">DEPTH[] DEPTH of the stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x24</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">n: number of elements (int32)</td>
      </tr>
    </table><br>
    Pushes n, the number of elements currently in the stack, onto the stack.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DIV"><font size="4">DIV[] DIVide</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x62</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n2: divisor (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">n1: dividend (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(n1 * 64)/n2: quotient (F26Dot6)</td>
      </tr>
    </table><br>
    Divides the number second from the top of the stack by the number at the top of the stack.<br>
    <p>Pops two 26.6 fixed point numbers, n1 and n2 off the stack and pushes onto the stack the quotient obtained by dividing n2 by n1. The division takes place in the following fashion, n1 is shifted left by six bits and then divided by 2.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="DUP"><font size="4">DUP[] DUPlicate top stack element</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x20</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle" rowspan="2">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">e: stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e: stack element (StkElt)</td>
      </tr>
    </table><br>
    Duplicates the top element on the stack.<br>
    <p>Pops an element, e, from the stack, duplicates that element and pushes it twice.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="EIF"><font size="4">EIF[] End IF</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x59</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">IF[ ], ELSE[ ]</td>
      </tr>
    </table><br>
    Marks the end of an IF or IF-ELSE instruction sequence.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ELSE"><font size="4">ELSE[] ELSE clause</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">IF[ ], EIF[ ]</td>
      </tr>
    </table>
    <p>Marks the start of the sequence of instructions that are to be executed when an IF instruction encounters a FALSE value on the stack. This sequence of instructions is terminated with an EIF instruction.<br></p>
    <p>The ELSE portion of an IF-ELSE-EIF sequence is optional.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ENDF"><font size="4">ENDF[] END Function definition</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x2D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FDEF[ ], IDEF[ ]</td>
      </tr>
    </table><br>
    Marks the end of a function definition or an instruction definition. Function definitions and instruction definitions cannot be nested.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="EQ"><font size="4">EQ[] EQual</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x54</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NEQ[ ]</td>
      </tr>
    </table><br>
    Tests whether the top two numbers on the stack are equal in value.<br>
    <p>Pops two 32 bit values, e2 and e1, from the stack and compares them. If they are the same, one, signifying TRUE is pushed onto the stack. If they are not equal, zero, signifying FALSE is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="EVEN"><font size="4">EVEN[] EVEN</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x57</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ODD[ ]</td>
      </tr>
    </table><br>
    Tests whether the number at the top of the stack, when rounded according to the round state, is even.<br>
    <p>Pops a 26.6 number, e, from the stack and rounds that number according to the current round state. The number is then truncated to an integer. If the truncated number is even, one, signifying TRUE, is pushed onto the stack; if it is odd, zero, signifying FALSE, is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FDEF"><font size="4">FDEF[] Function DEFinition</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x2C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">f: function identifier number (integer in the range 0 through (n-1) where n is specified in the 'maxp' table</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ENDF[ ], CALL[ ]</td>
      </tr>
    </table><br>
    Marks the start of a function definition and pops a number, f, from the stack to uniquely identify this function. That definition will terminate when an ENDF[] is encountered in the instruction stream. A function definition can appear only in the font program or the CVT program. Functions must be defined before they can be used with a CALL[ ] instruction.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLIPOFF"><font size="4">FLIPOFF[] set the auto FLIP Boolean to OFF</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x4E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">auto flip</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MIRP, MIAP</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLIPON[ ], MIRP[ ], MIAP[ ]</td>
      </tr>
    </table><br>
    Sets the auto flip Boolean in the graphics state to FALSE causing the MIRP[] and MIAP[] instructions to use the sign of control value table entries. When auto flip is set to FALSE, the direction in which distances are measured becomes significant. The default value for the auto flip state variable is TRUE.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLIPON"><font size="4">FLIPON[] set the auto FLIP Boolean to ON</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x4D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">auto flip</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MIRP, MIAP</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLIPOFF[ ], MIRP[ ], MIAP[ ]</td>
      </tr>
    </table><br>
    Sets the auto flip Boolean in the graphics state to TRUE causing the MIRP[] and MIAP[] instructions to ignore the sign of control value table entries. When the auto flip variable is TRUE, the direction in which distances are measured becomes insignificant. The default value for the auto flip state variable is TRUE.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLIPPT"><font size="4">FLIPPT[] FLIP PoinT</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x80</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p1, p2, , ploopvalue: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, loop</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLIPRGON[ ], FLIPRGOFF[ ]</td>
      </tr>
    </table><br>
    Makes an on-curve point an off-curve point or an off-curve point an on-curve point.<br>
    <p>Pops points, p, p1, p2, , ploopvalue from the stack. If pi is an on-curve point it is made an off-curve point. If pi is an off-curve point it is made an on-curve point. None of the points pi is marked as touched. As a result, none of the flipped points will be affected by an IUP[ ] instruction. A FLIPPT[ ] instruction redefines the shape of a glyph outline.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLIPRGOFF"><font size="4">FLIPRGOFF[] FLIP RanGe OFF</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x82</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">h: high point number in range (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">l: low point number in range (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLIPPT[ ], FLIPRGOFF[ ]</td>
      </tr>
    </table><br>
    Changes all of the points in the range specified to off-curve points.<br>
    <p>Pops two numbers defining a range of points, the first a highpoint and the second a lowpoint. On-curve points in this range will become off-curve points. The position of the points is not affected and accordingly the points are not marked as touched.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLIPRGON"><font size="4">FLIPRGON[] FLIP RanGe ON</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x81</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">h: highest point number in range of points to be flipped (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">l: lowest point number in range of points to be flipped (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">FLIPPT[ ], FLIPRGOFF[ ]</td>
      </tr>
    </table><br>
    Makes all the points in a specified range into on-curve points.<br>
    <p>Pops two numbers defining a range of points, the first a highpoint and the second a lowpoint. Off-curve points in this range will become on-curve points. The position of the points is not affected and accordingly the points are not marked as touched.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="FLOOR"><font size="4">FLOOR[] FLOOR</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x66</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: number whose floor is desired (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">n : floor of n (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">CEILING[ ]</td>
      </tr>
    </table>
    <p>Takes the floor of the value at the top of the stack.<br></p>
    <p>Pops a 26.6 fixed point number n from the stack and returns n , the greatest integer value less than or equal to n. Note that the floor of n, though an integer value, is expressed as 26.6 fixed point number.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GC"><font size="4">GC[a] Get Coordinate projected onto the projection vector</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x46 - 0x47</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: use current position of point p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: use the position of point p in the original outline</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">c: coordinate location (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp2, projection vector, dual projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SCFS[ ]</td>
      </tr>
    </table><br>
    Gets the coordinate value of the specified point using the current projection vector.<br>
    <p>Pops a point number p and pushes the coordinate value of that point on the current projection vector onto the stack. The value returned by GC[] is dependent upon the current direction of the projection vector.<br></p>
    <p>The illustration below, GC[1], with p1 at the top of the stack, returns the original position of point p1 while GC[0], with p2 at the top of the stack, returns the current position of point p2.<br>
    <img src="F025_instr4.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GETINFO"><font size="4">GETINFO[] GET INFOrmation</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x88</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">selector: integer (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">result: integer (uint32)</td>
      </tr>
    </table><br>
    Used to obtain data about the version of the TrueType engine that is rendering the font as well as the characteristics of the current glyph. The instruction pops a selector used to determine the type of information desired and pushes a result onto the stack.<br>
    <p>Setting bit 0 in the selector requests the engine version. Setting bit 1 asks whether the glyph has been rotated. Setting bit 2 asks whether the glyph has been stretched. To request information on two or more of these values, set the appropriate bits. For example, a selector value of 6 (0112) requests information on both rotation and stretching.<br></p>
    <p>The result is pushed onto the stack with the requested information. Bits 0 through 7 of result comprise the font engine version number. The version numbers are listed in TABLE 0-2.<br></p>
    <p>Bit 8 is set to 1 if the current glyph has been rotated. It is 0 otherwise. Bit 9 is set to 1 to indicate that the glyph has been stretched. It is 0 otherwise.<br></p>
    <p><font size="2"><strong>TABLE 0-1</strong> Selector bits and the results produced</font></p>
    <center>
      <strong>Table 6:</strong>
      <table border="1">
        <tr align="left" valign="middle">
          <th align="left" valign="middle">selector bits</th>
          <th align="left" valign="middle">meaning</th>
          <th align="left" valign="middle">result bits</th>
        </tr>
        <tr align="left" valign="middle">
          <td align="left" valign="middle">0</td>
          <td align="left" valign="middle">get engine version</td>
          <td align="left" valign="middle">0-7</td>
        </tr>
        <tr align="left" valign="middle">
          <td align="left" valign="middle">1</td>
          <td align="left" valign="middle">rotated?</td>
          <td align="left" valign="middle">8</td>
        </tr>
        <tr align="left" valign="middle">
          <td align="left" valign="middle">2</td>
          <td align="left" valign="middle">stretched?</td>
          <td align="left" valign="middle">9</td>
        </tr>
      </table>
    </center>
    <p>The possible values for the engine version are given in TABLE 0-2.<br></p>
    <p><font size="2"><strong>TABLE 0-2</strong> Font engine version number</font></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">System</th>
        <th align="left" valign="middle">Engine Version</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Macintosh System 6.0</td>
        <td align="left" valign="middle">1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Macintosh System 7.0</td>
        <td align="left" valign="middle">2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Windows 3.1</td>
        <td align="left" valign="middle">3</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">KanjiTalk 6.1</td>
        <td align="left" valign="middle">4</td>
      </tr>
    </table><br>
    If the TrueType engine is the System 7.0 version and the selector requested information on the version number, rotation and stretching and the glyph is rotated but not stretched, the result will be 01 0000 00102 or 258.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GFV"><font size="4">GFV[] Get Freedom Vector</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x0D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pushes</td>
        <td align="left" valign="middle">p<sub>x</sub>: x component (EF2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p<sub>y</sub>: y component (EF2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Gets</td>
        <td align="left" valign="middle">freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">GPV[ ]</td>
      </tr>
    </table>
    <p>Decomposes the current freedom vector into its x and y components and puts those components on the stack as two 2.14 numbers. The numbers occupy the least significant two bytes of each long.<br></p>
    <p>The first component pushed, px, is the x-component of the freedom vector. The second pushed, py, is the y-component of the freedom vector. Each is a 2.14 number.<br></p>
    <p>GFV[] treats the freedom vector as a unit vector originating at the grid origin. In the illustration below, the distance from point A to point B is 1 unit.<br>
    <img src="F025_instr5.gif"></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GPV"><font size="4">GPV[] Get Projection Vector</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x0C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pushes</td>
        <td align="left" valign="middle">p<sup>x</sup>: x component (EF2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p<sup>y</sup>: y component (EF2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Gets</td>
        <td align="left" valign="middle">projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">GFV[ ]</td>
      </tr>
    </table><br>
    Decomposes the current projection vector into its x and y components and pushes those components onto the stack as two 2.14 numbers.<br>
    <p>The first component pushed, px, is the x-component of the projection vector. The second pushed, py, is the y-component of the projection vector.<br></p>
    <p>GPV[] treats the projection vector as a unit vector originating at the grid origin. In the illustration below, the distance from point A to point B is one unit.<br>
    <img src="F025_instr6.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GT"><font size="4">GT[] Greater Than</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x52</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">LT[ ], GTEQ[ ]</td>
      </tr>
    </table><br>
    Compares the size of the top two stack elements.<br>
    <p>Pops two integers, e2 and e1, from the stack and compares them. If e1 is greater than e2, one, signifying TRUE, is pushed onto the stack. If e1 is not greater than e1, zero, signifying FALSE, is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="GTEQ"><font size="4">GTEQ[] Greater Than or EQual</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x53</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">LTEQ[ ], GT[ ]</td>
      </tr>
    </table><br>
    Compares the size of the top two stack elements.<br>
    <p>Pops two integers, e2 and e1, from the stack and compares them. If e1 is greater than or equal to e2, one, signifying TRUE, is pushed onto the stack. If e1 is not greater than or equal to e1, zero, signifying FALSE, is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="IDEF"><font size="4">IDEF[] Instruction DEFinition</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x89</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">opcode (Eint8)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ENDF[ ]</td>
      </tr>
    </table><br>
    Begins the definition of an instruction. The instruction is identified by the opcode popped. The intent of the IDEF[ ] instruction is to allow old versions of the scaler to work with fonts that use instructions defined in later releases of the TrueType interpreter. Referencing an undefined opcode will have no effect. The IDEF[ ] is not intended for creating user defined instructions. The FDEF[ ] should be used for that purpose.<br>
    <p>The instruction definition that began with the IDEF[ ] terminates when an ENDF[ ] is encountered in the instruction stream. Nested IDEFs are not allowed. Subsequent executions of the opcode popped will be directed to the contents of this instruction definition. IDEFs should be defined in the font program. Defining instructions in the CVT program is not recommended.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="IF"><font size="4">IF[] IF test</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x58</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ELSE[ ], EIF[ ]</td>
      </tr>
    </table><br>
    Marks the beginning of an if-statement.<br>
    <p>Pops an integer, e, from the stack. If e is zero (FALSE), the instruction pointer is moved to the associated ELSE or EIF[] instruction in the instruction stream. If e is nonzero (TRUE), the next instruction in the instruction stream is executed. Execution continues until the associated ELSE[] instruction is encountered or the associated EIF[] instruction ends the IF[] statement. If an associated ELSE[] statement is found before the EIF[], the instruction pointer is moved to the EIF[] statement.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="INSTCTRL"><font size="4">INSTCTRL[ ] INSTRuction execution ConTRoL</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x8E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">s: selector (int32) v: value for instruction control (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">instruction control</td>
      </tr>
    </table>
    <p>Sets the instruction control state variable making it possible to turn on or off the execution of instructions and to regulate use of parameters set in the CVT program.<br></p>
    <p>This instruction clears and sets various control flags. The selector is used to choose the relevant flag. The value determines the new setting of that flag.<br></p>
    <p>In the version 1.0 there are only two flags in use.<br></p>
    <p>Flag 1 is used to inhibit grid-fitting. It is chosen with a selector value of 1. If this flag is set to TRUE (v=1), any instructions associated with glyphs will not be executed. If the flag is FALSE (v=0), instructions will be executed. For example, to inhibit grid-fitting when a glyph is being rotated or stretched, use the following sequence on the preprogram:<br></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">PUSHB[000] 6</td>
        <td align="left" valign="middle">/* ask GETINFO to check for stretching or rotation */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">GETINFO[ ]</td>
        <td align="left" valign="middle">/* will push TRUE if glyph is stretched or rotated */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">IF[]</td>
        <td align="left" valign="middle">/* tests value at top of stack */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">PUSHB[000] 1</td>
        <td align="left" valign="middle">/* value for INSTCTRL */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">PUSHB[000] 1</td>
        <td align="left" valign="middle">/* selector for INSTCTRL */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">INSTCTRL[]</td>
        <td align="left" valign="middle">/* based on selector and value will turn grid-fitting off */</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" colspan="2">EIF[]</td>
      </tr>
    </table>
    <p>Flag 2 is used to establish that any parameters set in the CVT program should be ignored when instructions associated with glyphs are executed. These include, for example, the values for scantype and the CVT cut-in. When flag2 is set to TRUE the default values of those parameters will be used regardless of any changes that may have been made in those values by the preprogram. When flag2 is set to FALSE, parameter values changed by the CVT program will be used in glyph instructions.<br></p>
    <p>INSTCTRL[] can only be executed in the CVT program.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="IP"><font size="4">IP[] Interpolate Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x39</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p1, p2, , ploopvalue: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp1, zp1 with rp2, zp2 with point p, loop, freedom vector, projection vector, dual projection vector</td>
      </tr>
      <tr>
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">IUP[ ]</td>
      </tr>
    </table>
    <p>Interpolates the position of the specified points to preserve their original relationship with the reference points rp<sup>1</sup> and rp<sup>2</sup>.<br></p>
    <p>Pops point numbers, p<sup>1</sup>, p<sup>2</sup>, , ploopvalue, from the stack. Moves each point p<sup>i</sup> so that its relationship to rp<sup>1</sup> and rp<sup>2</sup> is the same as it was in the original uninstructed outline. That is, the following relationship holds:<br></p>
    <p><img src="function5-1.gif" alt="function5-1" align="absmiddle"></p>
    <p>This instruction is illegal if rp<sup>1</sup> and rp<sup>2</sup> occupy the same position on the projection vector.<br></p>
    <p>More intuitively, an IP[] instruction preserves the relative relationship of a point relative to two reference points.<br></p>
    <p>In the illustrations below, point p is interpolated relative to reference points rp<sup>1</sup> and rp<sup>2</sup>. In the first illustration, which depicts the situation before the IP[] instruction is executed, the distance from of point p to the original position of rp<sup>1</sup> is d1 and the distance from point p to the original position of point rp<sup>2</sup> is d2. The ratio of the two distances is d1:d2.<br>
    <img src="F025_instr7.gif"><br>
    The effect of the IP[] instruction is shown in the illustration below. It moves point p along the freedom vector until the ratio of the distance, d3, from the current position of rp1 to point p, to the distance, d4, from point p to the current position of point rp2 is equal to d1:d2. That is, point p is moved along the freedom vector until d1:d2 = d3:d4.when these distances are measured along the projection vector.<br>
    <img src="F025_instr8.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ISECT"><font size="4">ISECT[] moves point p to the InterSECTion of two lines</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x0F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="5">Pops</td>
        <td align="left" valign="middle">a<sup>0</sup>: start point of line A (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">a<sup>1</sup>: end point of line A (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">b<sup>0</sup>: start point of line B (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">b<sup>1</sup>: end point of line B (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p: point to move (uint32) Pushes -</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp<sup>2</sup> with point p, zp<sup>0</sup> with line A, zp1 with line B</td>
      </tr>
    </table>
    <p>Moves the specified point to the intersection of the two lines specified.<br></p>
    <p>Pops the end points of line A, a<sup>0</sup> and a<sup>1</sup>, followed by the end points of line B, b<sup>0</sup> and b<sup>1</sup> followed by point p. Puts point p at the intersection of the lines A and B. The points a<sup>0</sup> and a<sup>1</sup> define line A. Similarly, b<sup>0</sup> and b<sup>1</sup> define line B. ISECT ignores the freedom vector in moving point p.<br></p>
    <p>In the degenerate case of parallel lines A and B, the point is put in the middle. That is.<br></p>
    <p><img src="function5-2.gif" alt="function5-2" align="absmiddle"></p>
    <p><img src="function5-3.gif" alt="function5-3" align="absmiddle"><br></p>
    <p>In the illustration below, point p is moved from its current position to the intersection of the line defined by a<sup>0</sup>, a<sup>1</sup> and the line defined by b<sup>0</sup>, b<sup>1</sup>. Note that point p need not move along the freedom vector but is simply relocated at the point of intersection.<br>
    <img src="F025_instr9.gif"></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="IUP"><font size="4">IUP[a] Interpolate Untouched Points through the outline</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x30 - 0x31</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: interpolate in the y-direction</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: interpolate in the x-direction</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp<sup>2</sup></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">IP[ ]</td>
      </tr>
    </table>
    <p>Interpolates untouched points in the zone referenced by zp<sup>2</sup> to preserve the original relationship of the untouched points to the other points in that zone.<br></p>
    <p>Considers the reference glyph outline contour by contour, moving any untouched points that fall sequentially between a pair of touched points. How such a point is moved, however, depends on whether its projection fall between the projections of the touched points. That is, if the projected x-coordinate or y-coordinate (depending on whether the interpolation is in x or in y) of an untouched point were originally between those of the touched pair, that coordiante is linearly interpolated between the new coordinates of the touched points. Otherwise the untouched point is shifted by the amount the nearest touched point was shifted from its original outline position. The value of the Boolean a, determines whether the interpolation will be in the x-direction or the y-direction. The current settings of the freedom and projection vectors are not relevant.<br></p>
    <p>The set of fiigures below illustrates this distinction. The first illustration shows the contour before the IUP[] instruction is executed. Here p<sup>1</sup>, p<sup>2</sup>, p<sup>3</sup>, p<sup>4</sup> and p<sup>5</sup> are consecutive points on a contour. Point p<sup>2</sup>, p<sub>3</sub> and p<sub>4</sub> all fall sequentially between p<sub>1</sub> and p<sub>5</sub> on the contour. Assume that point p<sub>3</sub> has been touched.<br>
    <img src="F025_instr10.gif"><br></p>
    <p>Point p<sub>4</sub> has an x-coordinate that is between p<sub>1</sub> and p<sub>5</sub> while points p<sub>2</sub> and p<sub>3</sub> do not. Assume that p1 and p5 have been moved by a previous instructions and that point p<sub>3</sub> has been touched but not moved from its original position. As a result of an IUP[1] an interpolation in the x--direction takes place. Point p<sub>4</sub> will be linearly interpolated. Point p<sub>2</sub> will be shifted by the amount the nearest touched point was shifted. Point p<sub>3</sub> will be unaffected. (Points p<sub>2</sub> and p<sub>4</sub> are assumed to be in their original position. This is not strictly necessary as a point that has been moved can be untouched with the UTP[ ] instruction and hence subject to the actions of an IUP[ ] instruction.)<br></p>
    <p>As the result of the IUP[1] instruction, two points are moved. The first move is the shift illustrated below. Point p<sub>1</sub> has moved a distance ds units parallel to the x-axis from its original position. Point p<sub>2</sub> is moved parallel to the x-axis until it is at a distance equal to ds from its original position.<br>
    <img src="F025_instr11.gif"><br></p>
    <p>The second move is the linear interpolation shown in the illustration below. Point p4 is moved along the specified axis to a new position that preserves its relative distance from points p<sub>1</sub> and p<sub>5</sub>. After the interpolation the ratio of the original distance from point p<sub>4</sub> to p<sub>1</sub> (d<sub>1</sub>) to the original distance of point p<sub>4</sub> to p<sub>5</sub> (d<sub>2</sub>) is the same as the ratio of the new distance from point p<sub>4</sub> to p<sub>1</sub>(d<sub>3</sub>) to the new distance of point p<sub>4</sub> to p<sub>4</sub> (d<sub>4</sub>). That is: d<sub>1</sub>:d<sub>2</sub> = d<sub>3</sub>:d<sub>4</sub><br>
    <img src="F025_instr12.gif"><br></p>
    <p>This instruction operates on points in the glyph zone pointed to by zp<sub>2</sub>. This zone should always be zone 1. Applying IUP[ ] to zone 0 is illegal.<br></p>
    <p>The IUP[ ] instruction does not touch the points it moves. Thus the untouched points affected by an IUP[ ] instruction will be affected by subsequent IUP[] instructions unless they are touched by an intervening instruction.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="JMPR"><font size="4">JMPR[] JuMP Relative</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">offset: number of bytes to move instruction pointer (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">JROF[ ], JROT[ ]</td>
      </tr>
    </table><br>
    Moves the instruction pointer to a new location specified by the offset popped from the stack.<br>
    <p>Pops an integer offset from the stack. The signed offset is added to the instruction pointer and execution is resumed at the new location in the instruction steam. The jump is relative to the position of the instruction itself. That is, an offset of +1 causes the instruction immediately following the JMPR[] instruction to be executed.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="JROF"><font size="4">JROF[] Jump Relative On False</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x79</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element offset: number of bytes to move instruction pointer (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">JMPR[ ] JROT[ ]</td>
      </tr>
    </table>
    <p>Moves the instruction pointer to a new location specified by the offset popped from the stack if the element tested has a FALSE (zero) value.<br></p>
    <p>Pops a Boolean value, e and an offset. In the case where the Boolean, e, is FALSE, the signed offset will be added to the instruction pointer and execution will be resumed at the new location; otherwise, the jump is not taken. The jump is relative to the position of the instruction itself.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="JROT"><font size="4">JROT[] Jump Relative On True</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x78</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="3">Pops</td>
        <td align="left" valign="middle">e: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">offset: number of bytes to move</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">instruction pointer (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">JMPR[ ] JROF[ ]</td>
      </tr>
    </table><br>
    Moves the instruction pointer to a new location specified by the offset value popped from the stack if the element tested has a TRUE value.<br>
    <p>Pops a Boolean value, e and an offset. If the Boolean is TRUE (non-zero) the signed offset will be added to the instruction pointer and execution will be resumed at the address obtained. Otherwise, the jump is not taken. The jump is relative to the position of the instruction itself.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="LOOPCALL"><font size="4">LOOPCALL[] LOOP and CALL function</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x2A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">f: function number integer in the range 0 through (n-1) where n is specified in the 'maxp' table<br>
        count: number of times to call the function (signed word)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SLOOP[ ]</td>
      </tr>
    </table>
    <p>Repeatedly calls a function.<br></p>
    <p>Pops a function number f and a count. Calls the function, f, count number of times.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="LT"><font size="4">LT[] Less Than</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x50</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">e2: stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">GT[ ], LTEQ[ ]</td>
      </tr>
    </table>
    <p>Compares the two number at the top of the stack. The test succeeds if the second of the two numbers is smaller than the first.<br></p>
    <p>Pops two integers from the stack, e<sub>2</sub> and e<sub>1</sub>, and compares them. If e<sub>1</sub> is less than e<sub>2</sub>, 1, signifying TRUE, is pushed onto the stack. If e<sub>1</sub> is not less than e<sub>2</sub>, 0, signifying FALSE, is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="LTEQ"><font size="4">LTEQ[] Less Than or EQual</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x51</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">e2: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">GTEQ[ ], LT[ ]</td>
      </tr>
    </table><br>
    Compares the two numbers at the top of the stack. The test succeeds if the second of the two numbers is smaller than or equal to the first.<br>
    <p>Pops two integers, e2 and e1 from the stack and compares them. If e<sub>1</sub> is less than or equal to e<sub>2</sub>, one, signifying TRUE, is pushed onto the stack. If e<sub>1</sub> is greater than e<sub>2</sub>, zero, signifying FALSE, is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MAX"><font size="4">MAX[] MAXimum of top two stack elements</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x8B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">e2: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">maximum of e1 and e2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MIN[ ]</td>
      </tr>
    </table>
    <p>Returns the larger of the top two stack elements.<br></p>
    <p>Pops two elements, e<sub>2</sub> and e1, from the stack and pushes the larger of these two quantities onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MD"><font size="4">MD[a] Measure Distance</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x49 - 0x4A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: measure distance in grid-fitted outline</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: measure distance in original outline</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p2: point number (uint32) p1: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">d: distance (F26Dot6)</td>
      </tr>
    </table><br>
    Uses zp<sub>0</sub> with point p<sub>1</sub>, zp<sub>1</sub> with point p<sub>2</sub>, projection vector, dual projectionv ector<br>
    <p>Measures the distance between the two points specified.<br></p>
    <p>Pops two point numbers p<sub>2</sub> and p<sub>1</sub> and measures the distance between the two points specified. The distance, d, is pushed onto the stack as a pixel coordinate. The distance is signed. Reversing the order in which the points are listed will change the sign of the result.<br></p>
    <p>Depending upon the setting of the Boolean variable a, distance will be measured in the original outline or the grid-fitted outline. MD[0] measures the distance in the original outline while MD[1] measures the distance in the grid-fitted outline. As always, distance is measured along the projection vector. Just as reversing the order in which the points are listed will change the sign of the distance, reversing the orientation of the projection vector will have the same effect.<br></p>
    <p>In the example below, MD[1] will yield the original outline distance from point p<sub>1</sub> to point p<sub>2</sub>. MD[0] will yield the distance from point p<sub>1</sub> to point p<sub>2</sub>.<br>
    <img src="F025_instr13.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MDAP"><font size="4">MDAP[a] Move Direct Absolute Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x2E - 0x2F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a:</td>
        <td align="left" valign="middle">0: do not round the value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: round the value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">rp0 and rp1 are set to point p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, freedom vector, projection vector, round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MDRP[ ], MIAP[ ]</td>
      </tr>
    </table><br>
    Touch and, in some cases, round the specified point. A point that is "dapped" will be unaffected by subsequent IUP[ ] instructions and is generally intended to serve as a reference point for future instructions. Dapping a point with rounding set to grid will cause the point to have an integer valued coordinate along the projection vector. If the projection vector is set to the x-axis or y-axis, this will cause the point to be grid-aligned.<br>
    <p>Pops a point number, p, and sets reference points rp0 and rp1 to point p. If the Boolean a is set to 1, the coordinate of point p, as measured against the projection vector, will be rounded and then moved the rounded distance from its current position. If the Boolean a is set to 0, point p is not moved, but nonetheless is marked as touched in the direction(s) specified by the current freedom vector.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MDRP"><font size="4">MDRP[abcde] Move Direct Relative Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0xC0 - 0xDF</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: do not reset rp0 to point p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: set rp0 to point p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">b</td>
        <td align="left" valign="middle">0: do not keep distance greater than or equal to minimum distance</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: keep distance greater than or equal to minimum distance<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">c</td>
        <td align="left" valign="middle">0: do not round distance<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: round the distance<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">de</td>
        <td align="left" valign="middle">distance type for engine characteristic compensation<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">after point p is moved, rp1 is set equal to rp0, rp2 is set equal to point number p; if the a flag is set to TRUE, rp0 is set equal to point number p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp0 and zp1 with point p, minimum distance, round state,single width value, single width cut-in, freedom vector, projection vector, dual projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MDAP[ ], MIRP[ ]</td>
      </tr>
    </table>
    <p>Preserves the master outline distance between the specified point and the reference point rp<sub>0</sub>.<br></p>
    <p>Pops a point number, p, and moves point p along the freedom vector so that the distance from its new position to the current position of rp<sub>0</sub> is the same as the distance between the two points in the original uninstructed outline, and then adjusts it to be consistent with the Boolean settings. Note that it is only the original positions of rp<sub>0</sub> and point p and the current position of rp0 that determine the new position of point p along the freedom vector.<br></p>
    <p>MDRP[] is typically used to control the width or height of a glyph feature using a value which comes from the original outline. Since MDRP[] uses a direct measurement and does not reference the control value cut-in, it is used to control measurements that are unique to the glyph being instructed. Where there is a need to coordinate the control of a point with the treatment of points in other glyphs in the font, a MIRP[] instruction is needed.<br></p>
    <p>Though MDRP[] does not refer to the CVT, its effect does depend upon the single-width cut-in value. If the device space distance between the measured value taken from the uninstructed outline and the single width value is less than the single width cut-in, the single width value will be used in preference to the outline distance. In other words, if the two distances are sufficiently close (differ by less than the single width cut-in), the single width value will be used.<br></p>
    <p>The setting of the round state graphics state variable will determine whether and how the distance of point p from rp<sub>0</sub> is rounded. If the round bit is not set, the value will be unrounded. If the round bit is set, the effect will depend upon the choice of rounding state.<br></p>
    <p>A MDRP[] instruction can also be set to use the minimum distance value. Minimum distance sets a lower bound on the value the distance between two points can be rounded to.<br></p>
    <p>Distances measured with the MDRP[] instruction, like all TrueType distances, must be either black, white or grey. Indicating this value in Booleans de allows the interpreter to compensate for engine characteristics as needed.<br></p>
    <p>The illustration below, point p is moved along the freedom vector from its current position to a new position that is a distance, d from the reference point rp<sub>0</sub>. This distance is the same as the original distance from p to rp<sub>0</sub>.<br>
    <img src="F025_instr14.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MIAP"><font size="4">MIAP[a] Move Indirect Absolute Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x3E - 0x3F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: don't round the distance and don't look at the control value cut-in</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: round the distance and look at the control value cut-in</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n: CVT entry number (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">set rp0 and rp1 to point p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0, round state, control value cut-in, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MSIRP[ ], MIRP[ ], MDAP[ ]</td>
      </tr>
    </table>
    <p>Makes it possible to coordinate the location of a point with that of other similar points by moving that point to a location specified in the control value table.<br></p>
    <p>Pops a CVT entry number n and a point number p and then moves point p to the absolute coordinate position specified by the nth control value table entry. The coordinate is measured along the current projection vector. If boolean a has the value one, the position will be rounded as specified by round state. If boolean a has the value one and the device space difference between the CVT value and the original position is greater than the control value cut-in, the original position will be rounded (instead of the CVT value.)<br></p>
    <p>The a Boolean above controls both rounding and the use of the control value cut-in. To have this Boolean specify only whether or not the MIAP[] instruction should look at the control value cut-in value, use the ROFF[] instruction to turn off rounding.<br></p>
    <p>This instruction can be used to "create" twilight zone points. This is accomplished by setting zp0 to zone 0 and moving the specified point, which is initially at the origin to the desired location.<br></p>
    <p>In the illustration below, point p is moved along the freedom vector until it occupies a position that projects to c units along the projection vector.<br>
    <img src="F025_instr15.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MIN"><font size="4">MIN[] MINimum of top two stack elements</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x8C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">minimum of e1 and e2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MAX[ ]</td>
      </tr>
    </table>
    <p>Returns the minimum of the top two stack elements.<br></p>
    <p>Pops two elements, e2 and e1, from the stack and pushes the smaller of these two quantities onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MINDEX"><font size="4">MINDEX[] Move the INDEXed element to the top of the stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x26</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">k: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">ek: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="5">Stack before</td>
        <td align="left" valign="middle">k: stack element number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">...</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ek-1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ek: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="4">Stack after</td>
        <td align="left" valign="middle">ek: indexed element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">...</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ek-1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">CINDEX[ ]</td>
      </tr>
    </table>
    <p>Moves the indexed element to the top of the stack thereby removing it from its original position.<br></p>
    <p>Pops an integer, k, from the stack and moves the element with index k to the top of the stack.<br></p>
    <p><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MIRP"><font size="4">MIRP[abcde] Move Indirect Relative Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0xE0 - 0xFF</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: Do not set rp0 to p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: Set rp0 to p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">b</td>
        <td align="left" valign="middle">0: Do not keep distance greater than or equal to minimum distance</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: Keep distance greater than or equal to minimum distance</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">c</td>
        <td align="left" valign="middle">0: Do not round the distance and do not look at the control value cut-in</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: Round the distance and look at the control value cut-in value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">de:</td>
        <td align="left" valign="middle">distance type for engine characteristic compensation</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: CVT entry number (F26Dot6) p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp0 and zp1 with point p. round state, control value cut-in, single width value, single width cut-in, freedom vector, projection vector, auto flip, dual projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">After it has moved the point this instruction sets rp1 equal to rp0, rp2 is set equal to point number p; lastly, if a has the value TRUE, rp0 is set to point number p.</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MSIRP[ ], MIAP[ ], MDRP[ ]</td>
      </tr>
    </table><br>
    Makes it possible to coordinate the distance between a point and a reference point with other similar distances by making that distance subject to a control value table entry.<br>
    <p>Moves point p along the freedom vector so that the distance from p to the current position of rp<sub>0</sub> is equal to the distance stated in the referenced CVT entry, assuming that the cut-in test succeeds. Note that in making the cut-in test, MIRP[] uses the original outline distance between p and rp0. If the cut-in test fails, point p will be moved so that its distance from the current position of rp0 is equal to the original outline distance between p and the point referenced by rp<sub>0</sub>.<br></p>
    <p>A MIRP[] instruction makes it possible to preserve the distance between two points subject to a number of qualifications. Depending upon the setting of Boolean flag b, the distance can be kept greater than or equal to the value established by the minimum distance state variable. Similarly, the instruction can be set to round the distance according to the round state graphics state variable. The value of the minimum distance variable is the smallest possible value the distance between two points can be rounded to. Additionally, if the c Boolean is set, the MIRP[] instruction acts subject to the control value cut-in. If the difference between the actual measurement and the value in the CVT is sufficiently small (less than the cut-in value), the CVT value will be used and not the actual value. If the device space difference between the CVT value and the single width value is smaller than the single width cut-in, then use the single width value rather than the control value table distance.<br></p>
    <p>The c Boolean above controls both rounding and the use of control value table entries. If you would like the meaning of this Boolean to specify only whether or not the MIRP[] instruction should look at the control value cut-in, use the ROFF[] instruction to turn off rounding. In this manner, it is possible to specify that rounding is off but the cut-in still applies.<br></p>
    <p>MIRP[] can be used to create points in the twilight zone.<br></p>
    <p>In the illustration below, point p is moved along the freedom vector until its distance to point rp<sub>0</sub> is equal to the distance d found in the reference CVT entry.<br>
    <img src="F025_instr16.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MPPEM"><font size="4">MPPEM[] Measure Pixels Per EM</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x4B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">ppem: pixels per em (Euint16)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MPS[ ]</td>
      </tr>
    </table>
    <p>Pushes the current number of pixels per em onto the stack. Pixels per em is a function of the resolution of the rendering device and the current point size and the current transformation matrix. This instruction looks at the projection vector and returns the number of pixels per em in that direction. The number is always an integer.<br></p>
    <p>The illustration below shows magnifications of an 18 point Times New Roman s at 72 dpi, 144 dpi, and 300 dpi, respectively. Increasing the number of pixels per em improves the quality of the image obtained. It does not, however, change the absolute size of the image obtained.<br>
    <img src="F025_instr17.gif"></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">
          <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
          <p id="MPS"><font size="4">MPS[] Measure Point Size</font></p>
          
        </td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x4C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">pointSize: the current point size(Euint16)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MPPEM[ ]</td>
      </tr>
    </table>
    <p>Pushes the current point size onto the stack.<br></p>
    <p>Measure point size can be used to obtain a value which serves as the basis for choosing whether to branch to an alternative path through the instruction stream. It makes it possible to treat point sizes below or above a certain threshold differently.<br></p>
    <p>The illustration below shows magnifications of 12 point, 24 point, and 48point Times New Roman Q at 72 dpi. Note that increasing the point size of a glyph increases its absolute size. On a low resolution device, like a screen, more detail can be captured at a higher point size.<br>
    <img src="F025_instr18.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MSIRP"><font size="4">MSIRP[a] Move Stack Indirect Relative Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x3A - 0x3B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: do not change rp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: set rp0 to point number p</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">d: distance (F26Dot6) p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp1 with point p and zp0 with rp0, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MIRP[ ]</td>
      </tr>
    </table>
    <p>Makes it possible to coordinate the distance between a point and a reference point by setting the distance from a value popped from the stack.<br></p>
    <p>Pops a distance, d and a point number, p, and makes the distance between point p and the current position of rp0 equal to d. The distance, d, is in pixel coordinates.<br></p>
    <p>MSIRP[ ] is very similar to the MIRP[ ] instruction except for taking the distance from the stack rather than the CVT. Since MSIRP[ ] does not use the CVT, the control value cut-in is not a factor as it is in MIRP[ ]. Since MSIRP[ ] does not round, its effect is not dependent upon the round state.<br></p>
    <p>MSIRP[] can be used to create points in the twilight zone.<br></p>
    <p>In the illustration below, point p is moved along the freedom vector until it is at a distance d from rp0.<br>
    <img src="F025_instr19.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="MUL"><font size="4">MUL[] MULtiply</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x63</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n<sub>2</sub>: multiplier (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">n<sub>1</sub>: multiplicand (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(n<sub>2</sub> * n<sub>1</sub>)/64: product (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">DIV[ ]</td>
      </tr>
    </table><br>
    Multiplies the top two numbers on the stack. Pops two 26.6 numbers, n2 and n1, from the stack and pushes onto the stack the product of the two elements. The 52.12 result is shifted right by 6 bits and the high 26 bits are discarded yielding a 26.6 result.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NEG"><font size="4">NEG[] NEGate</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x65</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: pixel coordinate (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-n: negation of n1 (F26Dot6)</td>
      </tr>
    </table><br>
    Negates the number at the top of the stack.<br>
    <p>Pops a number, n, from the stack and pushes the negated value of n onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NEQ"><font size="4">NEQ[] Not EQual</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x55<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value (uint32 in the range [0,1])</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">EQ[ ]</td>
      </tr>
    </table><br>
    Determines whether the two elements at the top of the stack are unequal.<br>
    <p>Pops two numbers, e2 and e1, from the stack and compares them. If they are different, one, signifying TRUE is pushed onto the stack. If they are equal, zero, signifying FALSE is pushed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NOT"><font size="4">NOT[] logical NOT</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x5C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(not e): logical negation of e (uint32)</td>
      </tr>
    </table>
    <p>Takes the logical negation of the number at the top of the stack.<br></p>
    <p>Pops a number e from the stack and returns the result of a logical NOT operation performed on e. If e was zero, one is pushed onto the stack if e was nonzero, zero is pushed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NPUSHB"><font size="4">NPUSHB[] PUSH N Bytes</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x40</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">From IS</td>
        <td align="left" valign="middle">n: number of bytes to push (1 byte interpreted as an integer)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">b1, b2,...bn: sequence of n bytes</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b1, b2,...bn: sequence of n bytes each extended to 32 bits (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NPUSHW[ ], PUSHB[ ], PUSHW[]</td>
      </tr>
    </table>
    <p>Takes n bytes from the instruction stream and pushes them onto the stack.<br></p>
    <p>Looks at the next byte in the instructions stream, n, and takes n unsigned bytes from the instruction stream, where n is an unsigned integer in the range (0 255), and pushes them onto the stack. The number of bytes to push, n, is not pushed onto the stack.<br></p>
    <p>Each byte value is unsigned extended to 32 bits before being pushed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NPUSHW"><font size="4">NPUSHW[] PUSH N Words</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x41</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">From IS</td>
        <td align="left" valign="middle">n: number of words to push (one byte interpreted as an integer)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">w1, w2,...wn: sequence of n words formed from pairs of bytes, the high byte appearing first</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">w1, w2,...wn: sequence of n words each extended to 32 bits (int32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NPUSHW[ ], PUSHB[ ]</td>
      </tr>
    </table>
    <p>Takes n words from the instruction stream and pushes them onto the stack.<br></p>
    <p>Looks at the next instruction stream byte n and takes n 16-bit signed words from the instruction stream, where n is an unsigned integer in the range (0 255), and pushes them onto the stack. Each word is sign extended to 32 bits before being placed on the stack.The value n is not pushed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="NROUND"><font size="4">NROUND[ab] No ROUNDing of value</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x6C - 0x6F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">ab</td>
        <td align="left" valign="middle">distance type for engine characteristic compensation</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n<sub>1</sub>: pixel coordinate (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">n<sub>2</sub>: pixel coordinate (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ROUND[ ]</td>
      </tr>
    </table>
    <p>Changes the values of the number at the top of the stack to compensate for the engine characteristics.<br></p>
    <p>Pops a value, n1, from the stack and, possibly, increases or decreases its value to compensate for the engine characteristics established with the Boolean setting ab. The result, n<sub>2</sub>, is pushed onto the stack.<br></p>
    <p>NROUND[ab] derives its name from it relationship to ROUND[ab]. It does the same operation as ROUND[ab] except that it does not round the result obtained after compensating for the engine characteristics.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ODD"><font size="4">ODD[] ODD</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x56</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e1: stack element (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b: Boolean value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">EVEN[ ]</td>
      </tr>
    </table>
    <p>Tests whether the number at the top of the stack is odd.<br></p>
    <p>Pops a number, e1, from the stack and rounds it according to the current setting of the round state before testing it. The number is then truncated to an integer. If the truncated number is odd, one, signifying TRUE, is pushed onto the stack if it is even, zero, signifying FALSE is placed onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="OR"><font size="4">OR[] logical OR</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x5B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element e1: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(e1 or e2): logical or of e1 and e2 (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">AND[ ]</td>
      </tr>
    </table>
    <p>Takes the logical or of the two numbers at the top of the stack.<br></p>
    <p>Pops two numbers, e2 and e1 off the stack and pushes onto the stack the result of a logical or operation between the two elements. Zero is pushed if both of the elements are FALSE (have the value zero). One is pushed if either both of the elements are TRUE (has a nonzero value).<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="POP"><font size="4">POP[] POP top stack element</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x21</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
    </table><br>
    Pops the top element from the stack.<br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="PUSHB"><font size="4">PUSHB[abc] PUSH Bytes</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0xB0 - 0xB7</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">abc</td>
        <td align="left" valign="middle">number of bytes to be pushed - 1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">From IS</td>
        <td align="left" valign="middle">b0, b1, bn: sequence of n + 1 bytes where n = 4a+2b+c = abc2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">b0, b1, ,bn: sequence of n + 1 bytes each extended to 32 bits (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NPUSHB[ ], PUSHW[ ], NPUSHB[]</td>
      </tr>
    </table>
    <p>Takes the specified number of bytes from the instruction stream and pushes them onto the interpreter stack.<br></p>
    <p>The variables a, b, and c are binary digits representing numbers from 000 to 111 (0-7 in binary). The value 1 is automatically added to the abc figure to obtain the actual number of bytes pushed.<br></p>
    <p>When byte values are pushed onto the stack they are non-sign extended with zeroes to form 32 bit numbers.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="PUSHW"><font size="4">PUSHW[abc] PUSH Words</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0xB8 - 0xBF</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">abc</td>
        <td align="left" valign="middle">number of words to be pushed - 1.<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">From IS</td>
        <td align="left" valign="middle">w0,w1, wn: sequence of n+1 words formed from pairs of bytes, the high byte appearing first</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">w0,w1,...wn: sequence of n+1 words each padded to 32 bits (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NPUSHW[ ], PUSHB[ ]</td>
      </tr>
    </table>
    <p>Takes the specified number of words from the instruction stream and pushes them onto the interpreter stack.<br></p>
    <p>The variables a, b, and c are binary digits representing numbers from 000 to 111 (0-7 binary). The value 1 is automatically added to the abc figure to obtain the actual number of bytes pushed.<br></p>
    <p>When word values are pushed onto the stack they are sign extended to 32 bits.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RCVT"><font size="4">RCVT[] Read Control Value Table entry</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x45</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">location: CVT entry number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">value: CVT value (F26Dot6)<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">WCVTP[ ], WCVTP[ ]</td>
      </tr>
    </table>
    <p>Read a control value table entry and places its value onto the stack.<br></p>
    <p>Pops a CVT location from the stack and pushes the value found in the location specified onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RDTG"><font size="4">RDTG[] Round Down To Grid</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x7D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RUTG[ ], RTG[], RTHG[], RTDG[], ROFF[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to down to grid. In this state, distances are first subjected to compensation for the engine characteristics and then truncated to an integer. If the result of the compensation and rounding would be to change the sign of the distance, the distance is set to 0.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ROFF"><font size="4">ROFF[] Round OFF</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x7A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pop</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RDTG[], RUTG[ ], RTG[], RTHG[], RTDG[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to round off. In this state engine compensation occurs but no rounding takes place. If engine compensation would change the sign of a distance, the distance is set to 0.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ROLL"><font size="4">ROLL[] ROLL the top three stack elements</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range 0x8A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="3">Pops</td>
        <td align="left" valign="middle">a: top stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">b: second stack element from the top</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">c: third stack element from the top</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="3">Pushes</td>
        <td align="left" valign="middle">b: second stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">a: top stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">c: third stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">MINDEX[ ]</td>
      </tr>
    </table>
    <p>Performs a circular shift of the top three stack elements.<br></p>
    <p>Pops the top three stack elements, a, b, and c and performs a circular shift of these top three objects on the stack with the effect being to move the third element to the top of the stack and to move the first two elements down one position. ROLL is equivalent to MINDEX[] with the value 3 at the top of the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="ROUND"><font size="4">ROUND[ab] ROUND value</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x68 - 0x6B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Flags</td>
        <td align="left" valign="middle">ab: distance type for engine characteristic compensation</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n1: device space distance (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">n2: device space distance (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">NROUND[ ]</td>
      </tr>
    </table>
    <p>Uses round state, freedom vector<br></p>
    <p>Rounds the value at the top of the stack while compensating for the engine characteristics.<br></p>
    <p>Pops a 26.6 fixed point number, n1, and, depending on the engine characteristics established by Booleans ab, the result is increased or decreased by a set amount. The number obtained is then rounded according to the current rounding state and pushed back onto the stack as n2.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. See "Engine compensation using color" on page 2-65.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RS"><font size="4">RS[] Read Store</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x43</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: storage area location (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">v: storage area value (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">WS[ ]</td>
      </tr>
    </table>
    <p>Reads the value in the specified storage area location and pushes that value onto the stack.<br></p>
    <p>Pops a storage area location, n, from the stack and reads a 32-bit value, v, from that location. The value read is pushed onto the stack. The number of available storage locations is specified in the 'maxp' table in the font file'.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RTDG"><font size="4">RTDG[] Round To Double Grid</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x3D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RDTG[], ROFF[], RUTG[ ], RTG[], RTHG[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to double grid. In this state, distances are compensated for engine characteristics and then rounded to an integer or half-integer, whichever is closest.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. See "Engine compensation using color" on page 2-65.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RTG"><font size="4">RTG[] Round To Grid</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x18</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RDTG[], ROFF[], RUTG[ ], RTDG[], RTHG[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to grid. In this state, distances are compensated for engine characteristics and rounded to the nearest integer.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. See "Engine compensation using color" on page 2-65.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RTHG"><font size="4">RTHG[] Round To Half Grid</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x19</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RDTG[], ROFF[], RUTG[ ], RTDG[], RTG[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to half grid. In this state, distances are compensated for engine characteristics and rounded to the nearest half integer. If these operations change the sign of the distance, the distance is set to +1/2 or -1/2 according to the original sign of the distance.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. See "Engine compensation using color" on page 2-65.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="RUTG"><font size="4">RUTG[] Round Up To Grid</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x7C</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RDTG[], ROFF[], RTDG[], RTG[], RTHG[]</td>
      </tr>
    </table>
    <p>Sets the round state variable to up to grid. In this state, after compensation for the engine characteristics, distances are rounded up to the closest integer. If the compensation and rounding would change the sign of the distance, the distance will be set to 0.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. See "Engine compensation using color" on page 2-65.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="S45ROUND"><font size="4">S45ROUND[] Super ROUND 45 degrees</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x77</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: uint32 decomposed to obtain period, phase, threshold (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SROUND[ ]</td>
      </tr>
    </table>
    <p>S45ROUND[ ] is analogous to SROUND[ ]. The differ is that it uses a gridPeriod of pixels rather than 1 pixel. S45ROUND[ ] is useful for finely controlling rounding of distances that will be measured at a 45 angle to the x-axis.<br></p>
    <p><strong>Warning</strong><br></p>
    <p>In TrueType, rounding is symmetric about zero and includes compensation for printer dot size. "Engine compensation using color" on page 2-65.<br></p>
    <p>Pops a number, n, from the stack and decomposes that number to obtain a period, a phase and a threshold used to set the value of the graphics state variable round state. Only the lower 8 bits of the argument n are used to obtain these values. The byte is encoded as shown in Table 2 below.<br></p>
    <p><font size="2"><strong>Table 2</strong> SROUND[] byte encoding</font><br></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle" colspan="2">period</th>
        <th align="left" valign="middle" colspan="2">phrase</th>
        <th align="left" valign="middle" colspan="4">threshold</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">1</td>
        <td align="left" valign="middle">0</td>
      </tr>
    </table><br>
    The next three tables give the meaning associated with the possible values for the period, phase and threshold components of n in an S45ROUND[] instruction.<br>
    <p><font size="2"><strong>Table 3</strong> : Setting the period</font><br></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bit values</th>
        <th align="left" valign="middle">setting</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">00</td>
        <td align="left" valign="middle">sqr(2)/2 pixels</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">01</td>
        <td align="left" valign="middle">sqr(2) pixels</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">2sqr(2) pixels</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">Reserved</td>
      </tr>
    </table><br>
    <p><font size="2"><strong>Table 4</strong>: Setting the phase</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bits</th>
        <th align="left" valign="middle">phase</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">00</td>
        <td align="left" valign="middle">0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">01</td>
        <td align="left" valign="middle">period/4</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">period/2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">period*3/4</td>
      </tr>
    </table><br>
    <p><font size="2"><strong>Table 5</strong> : Setting the threshold</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bits</th>
        <th align="left" valign="middle">threshold</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0000</td>
        <td align="left" valign="middle">period -1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0001</td>
        <td align="left" valign="middle">-3/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0010</td>
        <td align="left" valign="middle">-2/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0011</td>
        <td align="left" valign="middle">-1/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0100</td>
        <td align="left" valign="middle">0/8 * period = 0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0101</td>
        <td align="left" valign="middle">1/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0110</td>
        <td align="left" valign="middle">2/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0111</td>
        <td align="left" valign="middle">3/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1000</td>
        <td align="left" valign="middle">4/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1001</td>
        <td align="left" valign="middle">5/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1010</td>
        <td align="left" valign="middle">6/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1011</td>
        <td align="left" valign="middle">7/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1100</td>
        <td align="left" valign="middle">8/8 * period = period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1101</td>
        <td align="left" valign="middle">9/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1110</td>
        <td align="left" valign="middle">10/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1111</td>
        <td align="left" valign="middle">11/8 * period</td>
      </tr>
    </table><br>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SANGW"><font size="4">SANGW[] Set ANGle Weight</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x7E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">weight: value for angle weight (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">angle weight</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related</td>
        <td align="left" valign="middle">instructions AA[ ]</td>
      </tr>
    </table>
    <p>Pops a 32 bit integer, weight, from the stack and sets the value of the angle weight state variable accordingly. This instruction is anachronistic. Except for popping a single stack element, it has no effect.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SCANCTRL"><font size="4">SCANCTRL[] SCAN conversion ConTRoL</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x85</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: flags indicating when to turn on dropout control mode</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">scan control</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SCANTYPE[ ]</td>
      </tr>
    </table>
    <p>Pops a number, n, which is decomposed to a set of flags specifying the dropout control mode. SCANCTRL is used to set the value of the graphics state variable scan control which in turn determines whether the scan converter will activate dropout control for this glyph. Use of the dropout control mode is determined by three conditions:<br></p>
    <ul>
      <li>Is the glyph rotated?</li>
      <li>Is the glyph stretched?</li>
      <li>Is the current setting for ppem less than a specified threshold?</li>
    </ul>
    <p>The interpreter pops a word from the stack and looks at the lower 13 bits.<br></p>
    <p>Bits 0-7 represent the threshold value for ppem. In conjunction with bit 8, a value of FF in bits 0-7 means invoke dropout control for all sizes. Sia value of 15 in bits 0-7 means invoke dropout control below 16 pixels per em. Note that 0xFE or 254 is the largest number of pixels per em for which dropout control can be selectively invoked.<br></p>
    <p>Bits 8-13 are used to specify when to dropout control. Bits 8, 9 and 10 are used to turn on the dropout control mode (assuming other conditions do not block it). Bits 11, 12, and 13 are used to turn off the dropout mode unless other conditions force it.<br></p>
    <table border="1" width="80%">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">Bit</th>
        <th align="left" valign="middle">Meaning If set</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">8</td>
        <td align="left" valign="middle">Set dropout control to TRUE if other conditions do not block and ppem is less than or equal to the threshold value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">9</td>
        <td align="left" valign="middle">Set dropout control to TRUE if other conditions do not block and the glyph is rotated</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">Set dropout control to TRUE if other conditions do not block and the glyph is stretched.</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">Set dropout control to FALSE unless ppem is less than or equal to the threshold value.</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">12</td>
        <td align="left" valign="middle">Set dropout control to FALSE unless the glyph is rotated.</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">13</td>
        <td align="left" valign="middle">Set dropout control to FALSE unless the glyph is stretched</td>
      </tr>
    </table><br>
    <p>For example, the values given below have the effect stated.<br></p>
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0x0</td>
        <td align="left" valign="middle">No dropout control is invoked</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0x1FF</td>
        <td align="left" valign="middle">Always do dropout control</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0xA10</td>
        <td align="left" valign="middle">Do dropout control if the glyph is rotated and has less than 16 pixels per em</td>
      </tr>
    </table>
    <p>The scan converter can operate in either a "normal" mode or in a "fix dropout" mode depending on the value of a set of enabling and disabling flags.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SCANTYPE"><font size="4">SCANTYPE[] SCANTYPE</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x8D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: stack element</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">scan_control</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SCANCTRL[ ]</td>
      </tr>
    </table><br>
    Used to choose between dropout control with subs and without stubs.<br>
    <p>Pops a stack element consisting of a16-bit integer extended to 32 bits. The value of this integer is used to determine which rules the scan converter will use. If the value of the argument is 2, the non-dropout control scan converter will be used. If the value of the integer is 0 or 1, the dropout control mode will be set. More specifically,<br></p>
    <p>if n=0 rules 1 and 2 are invoked (dropout control scan conversion including stubs)<br></p>
    <p>if n=1 rules 1 and 3 are invoked (dropout control scan conversion excluding stubs)<br></p>
    <p>if n=2 rule 1 is invoked (fast scan conversion)<br></p>
    <p>The scan conversion rules are shown here:<br></p>
    <p>Rule 1<br>
    If a pixel's center falls within or on the glyph outline, that pixel is turned on and becomes part of that glyph.<br></p>
    <p>Rule 2<br>
    If a scan line between two adjacent pixel centers (either vertical or horizontal) is intersected by both an on-Transition contour and an off-Transition contour and neither of the pixels was already turned on by rule 1, turn on the left-most pixel (horizontal scan line) or the bottom-most pixel (vertical scan line)<br></p>
    <p>Rule 3<br>
    Apply Rule 2 only if the two contours continue to intersect other scan lines in both directions. That is, do not turn on pixels for 'stubs'. The scanline segments that form a square with the intersected scan line segment are examined to verify that they are intersected by two contours. It is possible that these could be different contours than the ones intersecting the dropout scan line segment. This is very unlikely but may have to be controlled with grid-fitting in some exotic glyphs.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SCFS"><font size="4">SCFS[] Sets Coordinate From the Stack using projection vector and freedom vector</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x48</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">c: coordinate value (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp2, freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">GC[ ]</td>
      </tr>
    </table>
    <p>Moves a point to the position specified by the coordinate value given on the stack.<br></p>
    <p>Pops a coordinate value, c, and a point number, p, and moves point p from its current position along the freedom vector so that its component along the projection vector becomes the value popped off the stack.<br></p>
    <p>This instruction can be used to "create" points in the twilight zone.<br></p>
    <p>In the illustration below, point p is moved along the freedom vector until its coordinate on the projection vector has the value c.<br>
    <img src="F025_instr20.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SCVTCI"><font size="4">SCVTCI[] Set Control Value Table Cut-In</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1D</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for cut-in (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">control value cut-in</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MIAP, MIRP</td>
      </tr>
    </table>
    <p>Establish a new value for the control value table cut-in.<br></p>
    <p>Pops a value, n, from the stack and sets the control value cut-in to n. Increasing the value of the cut-in will increase the range of sizes for which CVT values will be used instead of the original outline value.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SDB"><font size="4">SDB[] Set Delta Base in the graphics state</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x5E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for the delta base (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">delta base</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">DELTAP1[], DELTAP2[], DELTAP3[], DELTAC1[], DELTAC2[], DELTAC3[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SDS[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for the delta base state variable thereby changing the range of values over which a DELTA[] instruction will have an affect.<br></p>
    <p>Pops a number, n, and sets delta base to the value n. The default for delta base is 9.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SDPVTL"><font size="4">SDPVTL[a] Set Dual Projection Vector To Line</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x86 - 0x87</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">a</td>
        <td align="left" valign="middle">0: Vector is parallel to line</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: Vector is perpendicular to line</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p2: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p1: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">dual projection vector, projection vector, zp2 with p2, zp1 with p1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SPVTL[ ]</td>
      </tr>
    </table>
    <p>Sets a second projection vector based upon the original position of two points. The new vector will point in a direction that is parallel to the line defined from p2 to p1. The projection vector is also set in in a direction that is parallel to the line from p2 to p1 but it is set using the current position of those points.<br></p>
    <p>Pops two point numbers from the stack and uses them to specify a line that defines a second, dual projection vector. This dual projection vector uses coordinates from the original outline before any instructions are executed. It is used only with the IP[], GC[], MD[], MDRP[] and MIRP[] instructions. The dual projection vector is used in place of the projection vector in these instructions. This continues until some instruction sets the projection vector again.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SDS"><font size="4">SDS[] Set Delta Shift in the graphics state</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x5F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for the delta shift (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">delta shift</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">DELTAP1[], DELTAP2[], DELTAP3[], DELTAC1[], DELTAC2[], DELTAC3[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SDB[ ]</td>
      </tr>
    </table>
    <p>Establish a new value for the delta shift state variable thereby changing the step size of the DELTA[] instructions.<br></p>
    <p>Pops a value n from the stack and sets delta shift to n. The default for delta shift is 3.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SFVFS"><font size="4">SFVFS[] Set Freedom Vector From Stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code</td>
        <td align="left" valign="middle">0x0B</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">y: y component of freedom vector (F2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">x: x component of freedom vector (F2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SFVTL[ ], SFVTPV[ ], SFVTCA[ ]</td>
      </tr>
    </table>
    <p>Changes the direction of the freedom vector using values take from the stack and thereby changing the direction in which points can move.<br></p>
    <p>Sets the direction of the freedom vector using the values x and y taken from the stack. The vector is set so that its projections onto the x and y -axes are x and y, which are specified as signed (two's complement) fixed-point (2.14) numbers. The value (x2 + y2) must be equal to 1 (0x4000).<br></p>
    <p><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SFVTCA"><font size="4">SFVTCA[a] Set Freedom Vector to Coordinate Axis</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code range</td>
        <td align="left" valign="middle">0x04 - 0x05</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: set the freedom vector to the y-axis</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: set the freedom vector to the x-axis</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SFVFS[ ], SFVTL[ ], SFVTPV[ ]</td>
      </tr>
    </table>
    <p>Sets the freedom vector to one of the coordinate axes depending upon the value of the flag a.<br></p>
    <p><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SFVTL"><font size="4">SFVTL[a] Set Freedom Vector To Line</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x08 - 0x09</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: set freedom vector to be parallel to the line segment defined by points p1 and p2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: set freedom vector perpendicular to the line segment defined by points p1 and p2; the vector is rotated counter clockwise 90 degrees</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">p2: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p1: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp1 points to the zone containing point p1 zp2 points to the zone containing point p2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SFVTPV[ ], SFVFS[ ], SFVTCA[ ]</td>
      </tr>
    </table>
    <p>Change the value of the freedom vector using the direction specified by the line whose end points are taken from the stack. The effect is to change the direction in which points can move to be parallel to that line. The order in which the points are chosen is significant. Reversing the order will reverse the direction of the freedom vector.<br></p>
    <p>Pops two point numbers p2 and p1 from the stack and sets the freedom vector to a unit vector parallel or perpendicular to the line segment defined by points p1 and p2 and pointing from p2 to p1.<br></p>
    <p>If the Boolean a has the value 0, the freedom vector is parallel to the line from p2 to p1.<br></p>
    <p>If the Boolean a has the value one, the freedom vector is perpendicular to the line from p2 to p1. More precisely, the freedom vector is obtained by rotating the vector that is parallel to the line 90 counter clockwise.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SFVTPV"><font size="4">SFVTPV[] Set Freedom Vector To Projection Vector</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code</td>
        <td align="left" valign="middle">0x0E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SFVFS[ ], SFVTL[ ], SFVTCA[ ]</td>
      </tr>
    </table>
    <p>Sets the freedom vector to be the same as the projection vector. This means that movement and measurement will be in the same direction.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SHC"><font size="4">SHC[a] SHift Contour using reference point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x34 - 0x35</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: uses rp2 in the zone pointed to by zp1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: uses rp1 in the zone pointed to by zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">c: contour to be shifted (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp1 or zp1 with rp2 depending on flag zp2 with contour c freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SHP[ ], SHZ[ ]</td>
      </tr>
    </table>
    <p>Shifts a contour by the amount that the reference point was shifted.<br></p>
    <p>Pops a number, c, and shifts every point on contour c by the same amount that the reference point has been shifted. Each point is shifted along the freedom vector so that the distance between the new position of the point and the old position of that point is the same as the distance between the current position of the reference point and the original position of the reference point. The distance is measured along the projection vector. If the reference point is one of the points defining the contour, the reference point is not moved by this instruction.<br></p>
    <p>This instruction is similar to SHP[], but every point on the contour is shifted.<br></p>
    <p>In the illustration below, the triangular contour formed by points ,, and is shifted by the amount, d, that reference point rp was moved from its original position. The new contour p1, p2, p3 retains the original shape but has been translated in space, along the freedom vector by the amount, d.<br>
    <img src="F025_instr21.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SHP"><font size="4">SHP[a] SHift Point using reference point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x32 - 0x33</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: uses rp2 in the zone pointed to by zp1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: uses rp1 in the zone pointed to by zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p1, p2, , ploopvalue: point to be shifted (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp1 or zp1 with rp2 depending on flag zp2 with point p loop, freedom vector, projection vector</td>
      </tr>
    </table>
    <p>Shifts points specified by the amount the reference point has already been shifted.</p>
    <p>Pops point numbers, p1, p2, , ploopvalue, and shifts those points by the same amount that the reference point has been shifted. Each point pi is moved along the freedom vector so that the distance between the new position of point pi and the current position of point pi is the same as the distance between the current position of the reference point and the original position of the reference point.<br></p>
    <p>In the illustration below, the distance between the current position of the reference point and its original position is d. Line LL' is drawn perpendicular to the projection vector at a distance d from point A'. Point p is moved along the freedom vector to the point where the vector intersects with line LL'. The distance from point A' to B', d, is now the same as the distance from A to B.<br>
    <img src="F025_instr22.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SHPIX"><font size="4">SHPIX[] SHift point by a PIXel amount</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x38</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">d: magnitude of the shift (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p1, p2, , ploopvalue: point to be shifted (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp2, loop, freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SHP[ ]</td>
      </tr>
    </table>
    <p>Shift the specified points by the specified amount.<br></p>
    <p>Pops point numbers p1, p2, , ploopvalue and an amount. Shifts each point pi by amount d.<br></p>
    <p>SHPIX[ ] is unique in relying solely on the direction of the freedom vector It makes no use of the projection vector. Measurement is made in the direction of the freedom vector.<br></p>
    <p>In the example below, point p is moved d pixels along the freedom vector.<br>
    <img src="F025_instr23.gif"><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SHZ"><font size="4">SHZ[a] SHift Zone using reference point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x36 - 0x37<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: the reference point rp2 is in the zone pointed to by zp1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: the reference point rp1 is in the zone pointed to by zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e: zone to be shifted (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with rp1 or zp1 with rp2 depending on flag freedom vector, projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SHP[ ], SHC[ ]</td>
      </tr>
    </table>
    <p>Shifts all of the points in the specified zone by the amount that the reference point has been shifted.<br></p>
    <p>Pops a zone number, e, and shifts the points in the specified zone (Z1 or Z0) by the same amount that the reference point has been shifted. The points in the zone are shifted so that the distance between the new position of the shifted points and their old position is the same as the distance between the current position of the reference point and the original position of the reference point.<br></p>
    <p>SHZ[a] uses zp0 with rp1 or zp1 with rp2. This instruction is similar to SHC[ ], but all points in the zone are shifted, not just the points on a single contour.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SLOOP"><font size="4">SLOOP[] Set LOOP variable</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x17</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for loop graphics state variable (integer)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">loop</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">ALIGNRP[], FLIPPT[], IP[], SHP[], SHPIX[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">LOOPCALL[ ]</td>
      </tr>
    </table>
    <p>Changes the value of the loop variable thereby changing the number of times the affected instructions will execute if called.<br></p>
    <p>Pops a value, n, from the stack and sets the loop variable count to that value. The loop variable works with the SHP[a], SHPIX[a], IP[ ], and ALIGNRP[]. The value n indicates the number of times the instruction is to be repeated. After the instruction executes the required number of times, the loop variable is reset to its default value of 1. Setting the loop variable to zero is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SMD"><font size="4">SMD[] Set Minimum Distance</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">distance: value for minimum_distance (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">minimum distance</td>
      </tr>
    </table>
    <p>Establishes a new value for the minimum distance, the smallest possible value to which distances will be rounded. An appropriate setting for this variable can prevent distances from rounding to zero and therefore disappearing when grid-fitting takes place.<br></p>
    <p>Pops a 26.6 value from the stack and sets the minimum distance variable to that value.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SPVFS"><font size="4">SPVFS[] Set Projection Vector From Stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x0A</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">y: y component of projection vector (F2Dot14) x: x component of projection vector (F2Dot14)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SPVTL[ ], SPVTCA[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for the projection vector using values taken from the stack.<br></p>
    <p>Pops two numbers y and x representing the y an x components of the projection vector. The values x and y are 2.14 numbers extended to 32 bits. Sets the direction of the projection vector, using values x and y taken from the stack, so that its projections onto the x and y-axes are x and y, which are specified as signed (two's complement) fixed-point (2.14) numbers. The value (x2 + y2) must be equal to 1 (0x4000).<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SPVTCA"><font size="4">SPVTCA[a] Set Projection Vector To Coordinate Axis</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code range</td>
        <td align="left" valign="middle">0x02 - 0x03</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: set the projection vector to the y-axis</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: set the projection vector to the x-axis</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SPVTL[ ], SPVFS[ ]</td>
      </tr>
    </table>
    <p>Sets the projection vector to one of the coordinate axes depending on the value of the flag a.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SPVTL"><font size="4">SPVTL[a] Set Projection Vector To Line</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x06 - 0x07<br></td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">a</td>
        <td align="left" valign="middle">0: sets projection vector to be parallel to line segment from p2 to p1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1: sets projection vector to be perpendicular to line segment from p2 to p1; the vector is rotated counter clockwise 90 degrees</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">p2: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">p1: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">point p1 in the zone pointed at by zp1 point p2 in the zone pointed at by zp2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">projection vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SPVFS[ ], SPVTCA[ ]</td>
      </tr>
    </table>
    <p>Changes the direction of the projection vector to that specified by the line defined by the endpoints taken from the stack. The order in which the points are specified is significant Reversing the order of the points will reverse the direction of the projection vector.<br></p>
    <p>Pops two point numbers, p2 and p1 and sets the projection vector to a unit vector parallel or perpendicular to the line segment from point p2 to point p1 and pointing from p2 to p1.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SROUND"><font size="4">SROUND[] Super ROUND</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x76</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: number decomposed to obtain period, phase, threshold (Eint8)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">round state</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MDAP[], MDRP[], MIAP[], MIRP[], ROUND[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">S45ROUND[ ]</td>
      </tr>
    </table>
    <p>Provides for fine control over the effects of the round state variable by directly setting the values of the three components of the round state: period, phase, and threshold.<br></p>
    <p>Pops a number, n, from the stack and decomposes that number to obtain a period, a phase and a threshold used to set the value of the graphics state variable round state. Only the lower 8 bits of the argument n are used to obtain these values. The byte is encoded as shown in Table 8 below.<br></p>
    <p><font size="2"><strong>Table 8</strong>: SROUND byte encoding</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle" colspan="2">period</th>
        <th align="left" valign="middle" colspan="2">phase</th>
        <th align="left" valign="middle" colspan="4">threshold</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">7</td>
        <td align="left" valign="middle">6</td>
        <td align="left" valign="middle">5</td>
        <td align="left" valign="middle">4</td>
        <td align="left" valign="middle">3</td>
        <td align="left" valign="middle">2</td>
        <td align="left" valign="middle">1</td>
      </tr>
    </table>
    <p>The period specifies the length of the separation or space between rounded values. The phase specifies the offset of the rounded values from multiples of the period. The threshold specifies the part of the domain, prior to a potential rounded value, that is mapped onto that value.Additional information on rounding can be found in "Rounding" on page 2-66.<br></p>
    <p>For SROUND[] the grid period used to compute the period shown in Table 9 is equal to 1.0 pixels. Table 10 lists the possible values for the phase and Table 11 the possible values for the threshold.,<br></p>
    <p><font size="2"><strong>Table 9</strong>: Setting the period</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bit value</th>
        <th align="left" valign="middle">setting</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">00</td>
        <td align="left" valign="middle">1/2 pixel</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">01</td>
        <td align="left" valign="middle">1 pixel</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">2 pixel</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">Reserved</td>
      </tr>
    </table>
    <p><br>
    <font size="2"><strong>Table 10</strong>: Setting the phase</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bit value</th>
        <th align="left" valign="middle">setting</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">00</td>
        <td align="left" valign="middle">0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">01</td>
        <td align="left" valign="middle">period/4</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">10</td>
        <td align="left" valign="middle">period/2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">11</td>
        <td align="left" valign="middle">period*3/4</td>
      </tr>
    </table>
    <p><br>
    <font size="2"><strong>Table 11</strong>: Setting the threshold</font></p>
    <table border="1">
      <tr align="left" valign="middle">
        <th align="left" valign="middle">bit value</th>
        <th align="left" valign="middle">setting</th>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0000</td>
        <td align="left" valign="middle">period -1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0001</td>
        <td align="left" valign="middle">-3/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0010</td>
        <td align="left" valign="middle">-2/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0011</td>
        <td align="left" valign="middle">-1/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0100</td>
        <td align="left" valign="middle">0/8 * period = 0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0101</td>
        <td align="left" valign="middle">1/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0110</td>
        <td align="left" valign="middle">2/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">0111</td>
        <td align="left" valign="middle">3/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1000</td>
        <td align="left" valign="middle">4/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1001</td>
        <td align="left" valign="middle">5/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1010</td>
        <td align="left" valign="middle">6/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1011</td>
        <td align="left" valign="middle">7/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1100</td>
        <td align="left" valign="middle">8/8 * period = period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1101</td>
        <td align="left" valign="middle">9/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1110</td>
        <td align="left" valign="middle">10/8 * period</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">1111</td>
        <td align="left" valign="middle">11/8 * period</td>
      </tr>
    </table>
    <p><br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SRPO"><font size="4">SRP0[] Set Reference Point 0</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x10</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">rp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">ALIGNRP[], MDAP[], MDRP[], MIAP[], MIRP[] MSIRP[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SRP1[ ], SRP2[ ]</td>
      </tr>
    </table>
    <p>Sets a new value for reference point 0.</p>
    <p>Pops a point number, p, from the stack and sets rp0 to p.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SRP1"><font size="4">SRP1[] Set Reference Point 1</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x11</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">rp1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">IP[], MDAP[], MIAP[], MSIRP[], SHC[], SHP[], SHZ</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SRP0[], SRP2[ ]</td>
      </tr>
    </table>
    <p>Sets a new value for reference point 1.<br></p>
    <p>Pops a point number, p, from the stack and sets rp1 to p.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SRP2"><font size="4">SRP2[] Set Reference Point 2</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x12</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">rp2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">IP[], SHC[], SHP[], SHZ[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SRP1[ ], SRP0[]</td>
      </tr>
    </table>
    <p>Sets a new value for reference point 2.<br></p>
    <p>Pops a point number, p, from the stack and sets rp2 to p.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SSW"><font size="4">SSW[] Set Single Width</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1F</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for single width value (FUnit)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">single width value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SSWCI[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for the single width value state variable. The single width value is used instead of a control value table entry when the difference between the single width value and the given CVT entry is less than the single width cut-in.<br></p>
    <p>Pops a 32 bit integer value, n, from the stack and sets the single width value in the graphics state to n. The value n is expressed in FUnits.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SSWCI"><font size="4">SSWCI[] Set Single Width Cut-In</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x1E</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: value for single width cut-in (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">single width cut-in</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">MIAP[], MIRP[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SSW[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for the single width cut-in, the distance difference at which the interpreter will ignore the values in the control value table in favor of the single width value.<br></p>
    <p>Pops a 32 bit integer value, n, and sets the single width cut-in to n.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SUB"><font size="4">SUB[] SUBtract</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x61</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle" rowspan="2">Pops</td>
        <td align="left" valign="middle">n2: subtrahend (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">n1: minuend (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">(n1 - n2): difference (F26Dot6)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">ADD[ ]</td>
      </tr>
    </table>
    <p>Subtracts the number at the top of the stack from the number below it.<br></p>
    <p>Pops two 26.6 numbers, n1 and n2, from the stack and pushes the difference between the two elements onto the stack.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SVTCA"><font size="4">SVTCA[a] Set freedom and projection Vectors To Coordinate Axis</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code range</td>
        <td align="left" valign="middle">0x00 - 0x01</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">a</td>
        <td align="left" valign="middle">0: set vectors to the y-axis<br>
        1: set vectors to the x-axis</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">projection vector<br>
        freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SPTCA[ ], SFVTCA[ ]</td>
      </tr>
    </table>
    <p>Sets both the projection vector and freedom vector to the same coordinate axis causing movement and measurement to be in the same direction. The setting of the Boolean variable a determines the choice of axis.<br></p>
    <p>SVTCA[ ] is a shortcut that replaces the SFVTCA[ ] and SPVTCA[ ] instructions. As a result, SVTCA[1] is equivalent to SFVTCA[1] followed by SPVTCA[1].<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SWAP"><font size="4">SWAP[] SWAP the top two elements on the stack</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x23</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">e2: stack element (StkElt)<br>
        e1: stack element (StkElt)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">e2: stack element (StkElt)<br>
        e1: stack element (StkElt)</td>
      </tr>
    </table>
    <p>Swaps the top two stack elements.<br></p>
    <p>Pops two elements, e2 and e1, from the stack and reverses their order making the old top element the second from the top and the old second element the top element.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SZP0"><font size="4">SZP0[] Set Zone Pointer 0</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x13</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: zone number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">zp0</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">AA[], ALIGNPTS[], ALIGNRP[], DELTAC1[], DELTAC2[], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[], FLIPPT[], FLIPRGOFF[], FLIPRGON[], IP[], ISECT[], MD[], MDAP[], MDRP[], MIAP[], MIRP[], MSIRP[], SHC[], SHE[], SHP[], SHZ[], UTP[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SZP1[ ], SZP2[ ], SZPS[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for zp0. It can point to either the glyph zone or the twilight zone.<br></p>
    <p>Pops a zone number, n, from the stack and sets zp0 to the zone with that number. If n has the value zero, zp0 points to zone 0 (the twilight zone). If n has the value one, zp0 points to zone 1 (the glyph zone). Any other value for n is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SZP1"><font size="4">SZP1[] Set Zone Pointer 1</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x14</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: zone number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">zp1</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">ALIGNPTS[], ALIGNRP[], IP[], ISECT[], MD[], MDRP[], MIRP[], MSIRP[], SDPVTL[], SFVTL[], SHC[], SHP[], SHZ[], SPVTL[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SZP0[ ], SZP2[ ], SZPS[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for zp1. It can point to either the glyph zone or the twilight zone.<br></p>
    <p>Pops a zone number, n, from the stack and sets zp1 to the zone with that number. If n has the value zero, zp1 points to zone 0 (the twilight zone). If n has the value one, zp1 points to zone 1 (the glyph zone). Any other value for n is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SZP2"><font size="4">SZP2[] Set Zone Pointer 2</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x15</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: zone number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">zp2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">IP[], ISECT[], IUP[], GC[], SDPVTL[], SHC[], SHP[], SFVTL[], SHPIX[], SPVTL[], SC[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SZP0[ ], SZP1[ ], SZPS[ ]</td>
      </tr>
    </table>
    <p>Establishes a new value for zp2. It can point to either the glyph zone or the twilight zone.<br></p>
    <p>Pops a zone number, n, from the stack and sets zp2 to the zone with that number. If n has the value zero, zp2 points to zone 0 (the twilight zone). If n has the value one, zp2 points to zone 1 (the glyph zone). Any other value for n is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="SZPS"><font size="4">SZPS[] Set Zone PointerS</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x16</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: zone number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">zp0, zp1, zp2</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">ALIGNPTS[], ALIGNRP[], DELTAC1[], DELTAC2[], DELTAC3[], DELTAP1[], DELTAP2[], DELTAP3[], FLIPPT[], FLIPRGOFF[], FLIPRGON[], GC[], IP[], ISECT[], IUP[], MD[], MDAP[], MDRP[], MIAP[], MIRP[], MSIRP[], SC[], SDPVTL[], SFVTL[], SHPIX[], SPVTL[], SHC[], SHP[], SHZ[], SPVTL[], UTP[]</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">SZP0[ ], SZP1[ ], SZP2[ ]</td>
      </tr>
    </table>
    <p>Sets all three zone pointers to refer to either the glyph zone or the twilight zone.<br></p>
    <p>Pops an integer n from the stack and sets all of the zone pointers to point to the zone with that number. If n is 0, all three zone pointers will point to zone 0 (the twilight zone). If n is 1, all three zone pointers will point to zone 1 (the glyph zone). Any other value for n is an error.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="UTP"><font size="4">UTP[] UnTouch Point</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x29</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">p: point number (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Uses</td>
        <td align="left" valign="middle">zp0 with point p, freedom vector</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Affects</td>
        <td align="left" valign="middle">IUP[ ]</td>
      </tr>
    </table>
    <p>Marks a point as untouched thereby causing the IUP[ ] instruction to affect its location.<br></p>
    <p>Pops a point number, p, and marks point p as untouched. A point may be touched in the x-direction, the y-direction, or in both the x and y-directions. The position of the freedom vector determines whether the point is untouched in the x-direction, the y-direction, or both. If the vector is set to the x-axis, the point will be untouched in the x-direction. If the vector is set to the y-axis, the point will be untouched in the y-direction. Otherwise the point will be untouched in both directions.<br></p>
    <p>A points that is marked as untouched will be moved by an IUP[ ] instruction even if the point was previously touched.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="WCVTF"><font size="4">WCVTF[] Write Control Value Table in Funits</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x70</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">n: number in FUnits (uint32) l: control value table location (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">control value table entry</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">WCVTP[ ]</td>
      </tr>
    </table>
    <p>Writes a scaled F26Dot6 value to the specified control value table location.<br></p>
    <p>Pops an integer value, n, and a control value table location l from the stack. The FUnit value is scaled to the current point size and resolution and put in the control value table. This instruction assumes the value is expressed in FUnits and not pixels.<br></p>
    <p>Since the CVT has been scaled to pixel values, the value taken from the stack is scaled to the appropriate pixel value before being written to the table.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="WCVTP"><font size="4">WCVTP[] Write Control Value Table in Pixel units</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x44</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">v: value in pixels (F26Dot6)<br>
        l: control value table location (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">control value table entry</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">WCVTF[ ]</td>
      </tr>
    </table>
    <p>Writes the value in pixels into the control value table location specified.<br></p>
    <p>Pops a value v and a control value table location l from the stack and puts that value in the specified location in the control value table. This instruction assumes the value taken from the stack is in pixels and not in FUnits. The value is written to the CVT table unchanged. The location l must be less than the number of storage locations specified in the 'maxp' table in the font file.<br></p>
    <p><a href="Chap5.html#contents">Return to Contents</a><br></p>
    <p id="WS"><font size="4">WS[] Write Store</font></p>
    
    <table width="80%">
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Code Range</td>
        <td align="left" valign="middle">0x42</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pops</td>
        <td align="left" valign="middle">v: storage area value (uint32)<br>
        l: storage area location (uint32)</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Pushes</td>
        <td align="left" valign="middle">-</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Sets</td>
        <td align="left" valign="middle">storage area value</td>
      </tr>
      <tr align="left" valign="middle">
        <td align="left" valign="middle">Related instructions</td>
        <td align="left" valign="middle">RS[ ]</td>
      </tr>
    </table>
    <p>Write the value taken from the stack to the specified storage area location.<br></p>
    <p>Pops a storage area location l, followed by a value, v. Writes this 32-bit value into the storage area location indexed by l. The value must be less than the number of storage locations specified in the 'maxp' table of the font file.</p>
  </div>

      </section>
  </div><!-- /content -->

  <div id="globalfooter">
    <div id="breadory">
      <ol id="breadcrumbs">
        <li class="home"><a href="../../../index.html">Developer</a></li>
        <li><a href="../../index.html">Fonts</a></li>
        <li><a href="../index.html">TrueType™ Reference Manual</a></li>
        <li>The Instruction Set</li>
      </ol>
      <div id="directorynav" class="directorynav">
	<div id="dn-cola" class="column">
		<h3><a href="../../../platforms/index.html">Platforms</a></h3>
		<ul>
			<li><a href="../../../ios/index.html">iOS</a></li>
			<li><a href="../../../osx/index.html">OS X</a></li>
			<li><a href="../../../watchos/index.html">watchOS</a></li>
			<li><a href="../../../tvos/index.html">tvOS</a></li>
		</ul>
		<h3><a href="../../../resources/index.html">Tools</a></h3>
		<ul>
			<li><a href="../../../xcode/index.html">Xcode</a></li>
			<li><a href="../../../swift/index.html">Swift</a></li>
		</ul>
	</div>
	<div id="dn-colb" class="column">
		<h3><a href="../../../resources/index.html">Resources</a></h3>
		<ul>
			<li><a href="../../../library/index.html">Documentation</a></li>
			<li><a href="../../../videos/index.html">Videos</a></li>
			<li><a href="https://forums.developer.apple.com/">Forums</a></li>
			<li><a href="../../../app-store/index.html">App Store</a></li>
			<li><a href="../../../safari/index.html">Safari and Web</a></li>
			<li><a href="../../../education/index.html">Education</a></li>
			<li><a href="../../../enterprise/index.html">Enterprise</a></li>
		</ul>
	</div>
	<div id="dn-colc" class="column">
		<h3><a href="../../../programs/index.html">Programs</a></h3>
		<ul>
			<li><a href="../../../programs/index.html">Developer Program</a></li>
			<li><a href="../../../programs/enterprise/index.html">Enterprise Program</a></li>
			<li><a href="../../../programs/ios/university/index.html">iOS University Program</a></li>
			<li><a href="../../../programs/mfi/index.html">MFi Program</a></li>
		</ul>
	</div>
	<div id="dn-cold" class="column">
		<h3><a href="../../../support/index.html">Support</a></h3>
		<ul>
			<li><a href="../../../support/development/index.html">Development</a></li>
			<li><a href="../../../support/distribution/index.html">Distribution</a></li>
			<li><a href="../../../support/membership/index.html">Membership</a></li>
			<li><a href="../../../system-status/index.html">System Status</a></li>
		</ul>
	</div>
	<div id="dn-cole" class="column">
		<h3><a href="https://developer.apple.com/account/">Account</a></h3>
		<ul>
			<li><a href="https://developer.apple.com/account/">Developer Account</a></li>
			<li><a href="../../../go/index-id=certificates-ids-profiles.html">Certificates, IDs &amp; Profiles</a></li>
			<li><a href="https://itunesconnect.apple.com">iTunes Connect</a></li>			
			<li><a href="../../../terms/index.html">License Agreements</a></li>
		</ul>
	</div>
</div>

    </div><!--/breadory-->
    <ul class="gf-links piped footer-links">
  <li><a href="../../../news/index.html" class="first">News &amp; Updates</a></li>
  <li><a href="../../../bug-reporting/index.html">Report Bugs</a></li>
  <li><a href="../../../contact/index.html">Contact Us</a></li>
</ul>

<div class="gf-sosumi footer-sosumi">
  <p>Copyright © 2016 Apple Inc. All rights reserved.</p>
    <ul class="piped">
        <li><a href="http://www.apple.com/legal/internet-services/terms/site.html" class="first">Terms of Use</a></li>
        <li><a href="http://www.apple.com/privacy/privacy-policy/">Privacy Policy</a></li>
    </ul>
</div>

<!--<div id="gf-links piped footer-links">
	<ul>
		<li><a href="/cn/" title="Simplified Chinese">简体中文</a></li>
		<li><a href="/jp/" title="Japanese">日本語</a></li>
		<li><a href="/kr/" title="Korean">한국어</a></li>
	</ul>
</div>-->

  </div><!--/globalfooter-->
</body>
</html>